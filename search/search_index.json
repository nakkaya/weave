{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Weave is an easy-to-use, Clojure-based web application framework.</p> <p>Weave enables the creation of full-stack web applications in Clojure including the user interface. It's great for micro web apps, dashboards, admin interfaces, smart home solutions, and similar use cases.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Browser-based graphical user interface with real-time updates</li> <li>Reactive UI with server-sent events (SSE) for instant updates</li> <li>Standard GUI elements like labels, buttons, forms, and inputs</li> <li>Simple component organization with Hiccup syntax</li> <li>Client-side routing with hash-based navigation</li> <li>Built-in session management and authentication</li> <li>Server-side rendering with client-side interactivity</li> <li>Push updates to specific browser tabs or broadcast to all sessions</li> <li>GraalVM compatible. See <code>demo/Dockerfile</code> for static single   executable builds</li> <li>Automatically generate and serve the needed resources for   Progressive Web Apps (PWA)</li> </ul>"},{"location":"#why-weave","title":"Why Weave?","text":"<p>Weave combines the simplicity of Hiccup templates with the power of server-side rendering and real-time updates.  It provides a cohesive development experience where your UI logic lives alongside your application code.</p> <p>Unlike traditional SPAs that require separate frontend and backend codebases, Weave lets you build interactive web applications using only Clojure. The server pushes UI updates directly to the browser using server-sent events, eliminating the need for complex client-side JavaScript frameworks.</p>"},{"location":"create_a_project/","title":"Create a Project","text":"<p>Requirements:</p> <ul> <li>Java 11 or higher</li> <li>Clojure</li> </ul> <p>Weave is designed with simplicity in mind, you only need two files to get started.</p> <ul> <li><code>deps.edn</code></li> <li><code>src/app/core.clj</code></li> </ul> <p>Create a file called <code>deps.edn</code>,</p> <pre><code>{:paths   [\"src\"]\n\n :deps    {org.clojure/clojure {:mvn/version \"1.12.0\"}\n           weave/core {:git/url \"https://github.com/nakkaya/weave/\"\n                       :git/sha \"1913452b68cd64a50411c9cd980811b1a27901fa\"}}\n\n :aliases {:dev {:exec-fn app.core/run}}}\n</code></pre> <p>Then in <code>src/app/core.clj</code></p> <pre><code>(ns app.core\n  (:require [weave.core :as weave]))\n\n(defn view []\n  [:div.p-6\n   [:h1#label.text-2xl.font-bold \"Hello Weave!\"]\n   [:button.bg-blue-500.text-white.px-4.py-2.rounded\n    {:data-on-click\n     (weave/handler []\n      (weave/push-html!\n       [:h1#label.text-2xl.font-bold \"Button was clicked!\"]))}\n    \"CLICK ME\"]])\n\n(defn run [_opts]\n  (weave/run #'view {}))\n</code></pre> <p>Run <code>clj -X:dev</code> to start the app on <code>http://localhost:8080</code></p>"},{"location":"create_a_project/#understanding-the-basics","title":"Understanding the Basics","text":""},{"location":"create_a_project/#markup","title":"Markup","text":"<p>Weave uses Chassis DSL for defining HTML elements in Clojure. </p> <ul> <li>Elements are represented as Clojure vectors: <code>[:div \"content\"]</code></li> <li>CSS classes are added with dot notation: <code>[:div.my-class \"content\"]</code></li> <li>IDs are added with hash notation: <code>[:h1#title \"Hello\"]</code></li> <li>Attributes are specified in a map: <code>[:button {:disabled true} \"Click\"]</code></li> <li>Tailwind CSS classes work seamlessly: <code>[:div.p-4.bg-blue-500 \"Styled content\"]</code></li> </ul>"},{"location":"create_a_project/#event-handlers","title":"Event Handlers","text":"<p>Weave uses Datastar on the client side for its reactive event handling system:</p> <ul> <li>Events are attached with data attributes: <code>:data-on-click /   :data-on-load /</code> etc.</li> <li>The <code>weave/handler</code> macro creates server-side event handlers</li> <li>Handlers can update the DOM, merge one or more fragments using   <code>push-html!</code> or <code>broadcast-html!</code>. By default,   Datastar merges fragments using Idiomorph,   which matches top level elements based on their ID</li> </ul>"},{"location":"create_a_project/#server-side-rendering","title":"Server-Side Rendering","text":"<ul> <li>The <code>view</code> function defines your initial UI state</li> <li>All rendering happens on the server</li> <li>Updates are pushed to the client via Server-Sent Events (SSE)</li> </ul>"},{"location":"reference/10_handlers/","title":"Handlers","text":"<p>Handlers are server-side functions that process client-side events. They are a core part of Weave's reactivity model.</p>"},{"location":"reference/10_handlers/#how-handlers-work","title":"How Handlers Work","text":"<ul> <li> <p>When you define a handler using the <code>weave/handler</code> macro, Weave:</p> <ul> <li>Generates a unique route path based on code structure and   captured variables. A hash is calculated for each handler,   handlers with the same hash share the same unique route</li> <li>Registers the handler function with that route</li> <li>Returns client-side Datastar   expression that will invoke this route when triggered</li> </ul> </li> <li> <p>When a client-side event occurs (like a button click):</p> <ul> <li>The browser sends a request to the unique route</li> <li>Weave executes your handler function on the server</li> <li>Your handler can update the DOM, execute scripts, etc.</li> </ul> </li> </ul>"},{"location":"reference/10_handlers/#handler-syntax","title":"Handler Syntax","text":"<pre><code>(weave/handler ^{options} [arguments]\n  ;; handler body\n  )\n</code></pre>"},{"location":"reference/10_handlers/#variable-capture","title":"Variable Capture","text":"<p>Any variables accessed within the handler body must be explicitly captured in the first argument vector. This is required for proper caching and ensures handlers work correctly with closures:</p> <pre><code>(let [user-name \"John\"\n      counter (atom 0)]\n  (weave/handler [user-name counter]\n    (weave/push-html! [:div \"Hello \" user-name \"! Count: \" @counter])))\n</code></pre>"},{"location":"reference/10_handlers/#handler-options","title":"Handler Options","text":"<p>Options are provided as metadata (optional):</p> <ul> <li><code>:auth-required?</code> - Whether authentication is required (defaults to   the value from <code>:handler-options</code> in the run configuration)</li> <li><code>:type</code> - Request content type (use <code>:form</code> for form submissions)</li> <li><code>:selector</code> - CSS selector for the form to submit (e.g. <code>\"#myform\"</code>)</li> <li><code>:request-cancellation</code> - Controls request cancellation behavior   (see Request Cancellation)</li> <li><code>:confirm</code> - String message for confirmation dialog. When present,   shows a browser <code>confirm()</code> dialog before executing the handler.   Example: <code>^{:confirm \"Are you sure you want to delete this item?\"} []</code></li> </ul>"},{"location":"reference/10_handlers/#request-cancellation","title":"Request Cancellation","text":"<p>Weave provides different modes for handling duplicate or rapid requests to the same handler route:</p>"},{"location":"reference/10_handlers/#auto-mode-default","title":"Auto Mode (Default)","text":"<pre><code>;; Default behavior - no need to specify\n(weave/handler []\n  (weave/push-html! [:div \"Processing...\"]))\n\n;; Explicitly specified\n(weave/handler ^{:request-cancellation \"auto\"} []\n  (weave/push-html! [:div \"Processing...\"]))\n</code></pre> <p>Behavior: When a user rapidly clicks the same button:</p> <ul> <li>The first request starts processing</li> <li>If a second click occurs before the first request completes, the   first request is cancelled</li> <li>The second request proceeds normally</li> <li>Only the latest request will complete</li> </ul> <p>Use case: Standard UI interactions where only the most recent user action matters.</p>"},{"location":"reference/10_handlers/#serialize-mode","title":"Serialize Mode","text":"<pre><code>(weave/handler ^{:request-cancellation \"serialize\"} []\n  ;; This operation will be serialized per route\n  (Thread/sleep 2000) ; Simulate slow operation\n  (weave/push-html! [:div \"Operation completed\"]))\n</code></pre> <p>Behavior: When a user rapidly clicks the same button:</p> <ul> <li>The first request starts processing and completes fully</li> <li>Additional clicks are silently ignored until the first request finishes</li> <li>Once the first request completes, new requests are allowed</li> <li>Ensures no duplicate operations occur</li> </ul> <p>Use case: Critical operations like database writes, payments, or any action that should not be duplicated.</p>"},{"location":"reference/10_handlers/#disabled-mode","title":"Disabled Mode","text":"<pre><code>(weave/handler ^{:request-cancellation \"disabled\"} []\n  (weave/push-html! [:div \"Processing...\"]))\n</code></pre> <p>Behavior: All requests are allowed to proceed concurrently.</p> <p>Use case: When you want to allow multiple simultaneous requests to the same handler.</p>"},{"location":"reference/10_handlers/#signal-naming-conventions","title":"Signal Naming Conventions","text":"<p>Weave automatically converts signal names between Clojure's kebab-case convention and JavaScript's camelCase convention:</p>"},{"location":"reference/10_handlers/#clojure-to-javascript-outgoing-signals","title":"Clojure to JavaScript (Outgoing Signals)","text":"<p>When you use <code>push-signal!</code> or similar functions, signal names are converted from kebab-case keywords to camelCase:</p> <pre><code>;; In your handler\n(weave/push-signal! {:user-name \"John\"\n                     :is-active true\n                     :item-count 42})\n\n;; JavaScript receives:\n;; {userName: \"John\", isActive: true, itemCount: 42}\n</code></pre>"},{"location":"reference/10_handlers/#javascript-to-clojure-incoming-signals","title":"JavaScript to Clojure (Incoming Signals)","text":"<p>When signals are sent from the browser (via Datastar), they are converted from camelCase to kebab-case keywords:</p> <pre><code>&lt;!-- In your HTML --&gt;\n&lt;div data-signals-userName=\"John\"\n     data-signals-isActive=\"true\"\n     data-signals-itemCount=\"42\"&gt;\n</code></pre> <pre><code>;; In your handler, signals are accessible as:\n(let [{:keys [user-name is-active item-count]} weave/*signals*]\n  ;; user-name = \"John\"\n  ;; is-active = true\n  ;; item-count = 42\n  )\n</code></pre>"},{"location":"reference/10_handlers/#accessing-url-query-parameters","title":"Accessing URL Query Parameters","text":"<p>Weave automatically parses URL query parameters and makes them available to handlers through the <code>weave/*query-params*</code> dynamic variable. Query parameters are extracted from the URL hash and parsed into a map with keyword keys.</p>"},{"location":"reference/10_handlers/#url-structure","title":"URL Structure","text":"<p>Query parameters can be included in the URL hash: <pre><code>https://your-app.com/#/dashboard?tab=settings&amp;view=compact&amp;debug\n</code></pre></p>"},{"location":"reference/10_handlers/#accessing-query-parameters-in-handlers","title":"Accessing Query Parameters in Handlers","text":"<pre><code>(defn dashboard-view []\n  [:div\n   [:button\n    {:data-on-click\n     (weave/handler []\n       (let [{:keys [tab view debug]} weave/*query-params*]\n         (weave/push-html!\n          [:div\n           [:p \"Current tab: \" (or tab \"default\")]\n           [:p \"View mode: \" (or view \"normal\")]\n           [:p \"Debug mode: \" (if debug \"enabled\" \"disabled\")]])))}\n    \"Show Query Params\"]])\n</code></pre>"},{"location":"reference/10_handlers/#examples","title":"Examples","text":""},{"location":"reference/10_handlers/#with-variables","title":"With Variables","text":"<pre><code>(let [message \"Hello from server!\"]\n  {:data-on-click\n   (weave/handler [message]\n    (weave/push-html! [:div#message message]))})\n</code></pre> <p>When this handler is registered, Weave:</p> <ul> <li>Creates a unique route based on the handler code and captured    variables.</li> <li>Sets up a POST endpoint for that route</li> <li>Returns client-side code that will POST to that route when the    click event occurs</li> </ul>"},{"location":"reference/10_handlers/#with-signals","title":"With Signals","text":"<p>Signals provide a powerful alternative to variable capture for managing dynamic state. Instead of capturing variables in closures, you can store state as signals in the browser and access them via <code>weave/*signals*</code>.</p> <pre><code>(defn click-count-view []\n  [::c/view#app\n   [::c/center-hv\n    [::c/card\n     [:div.text-center.text-6xl.font-bold.mb-6.text-blue-600\n      {:data-signals-count \"0\"\n       :data-text \"$count\"}]\n     [::c/button\n      {:size :xl\n       :variant :primary\n       :data-on-click (weave/handler []\n                        (let [count (or (:count weave/*signals*) 0)]\n                          (weave/push-signal! {:count (inc count)})))}\n      \"Increment Count\"]]]])\n</code></pre> <p>In this example:</p> <ul> <li><code>data-signals-click-count=\"0\"</code> initializes the signal with value 0</li> <li><code>data-text=\"$click\"</code> displays the signal value reactively</li> <li>The handler reads the current value from <code>weave/*signals*</code> and   updates it with <code>push-signal!</code></li> </ul>"},{"location":"reference/10_handlers/#with-data-call-with-","title":"With <code>:data-call-with-*</code>","text":"<p>The <code>:data-call-with-*</code> attribute is a Weave-specific feature that provides way to pass arguments to handlers while avoiding variable capture.</p> <pre><code>(defn action-buttons-view []\n  [:div#app\n   [:div#result \"No action performed yet\"]\n   ;; Define a single shared handler\n   (let [handle-action (weave/handler []\n                         (let [{:keys [action item-id]} weave/*signals*]\n                           (weave/push-html!\n                             [:div#result (str \"Action: \" action \", Item: \" item-id)])))]\n     [:div.button-group\n      [::c/button\n       {:data-call-with-action \"edit\"\n        :data-call-with-item-id \"123\"\n        :data-on-click handle-action}\n       \"Edit\"]\n      [::c/button\n       {:data-call-with-action \"delete\"\n        :data-call-with-item-id \"123\"\n        :data-on-click handle-action}\n       \"Delete\"]])])\n</code></pre>"},{"location":"reference/10_handlers/#scoping-rules","title":"Scoping Rules","text":"<pre><code>;; Example showing inheritance\n[:div {:data-call-with-action \"noop\"}  ; Parent element\n [:button {:data-call-with-action \"edit\"  ; Child element\n           :data-call-with-id \"123\"\n           :data-on-click handler}\n  \"Edit User\"]]\n;; Result: signals will be {:action \"edit\", :id \"123\"}\n</code></pre>"},{"location":"reference/10_handlers/#with-confirmation-dialog","title":"With Confirmation Dialog","text":"<pre><code>;; Simple delete confirmation\n{:data-on-click\n (weave/handler ^{:confirm \"Are you sure you want to delete this item?\"} []\n   (delete-item!)\n   (weave/push-html! [:div \"Item deleted\"]))}\n</code></pre> <p>The <code>:confirm</code> option generates JavaScript that shows a browser confirmation dialog before executing the handler. If the user clicks \"Cancel\", the handler will not execute.</p>"},{"location":"reference/10_handlers/#problem-route-explosion-with-closures","title":"Problem: Route Explosion with Closures","text":"<p>When using variable capture, each unique combination of captured variables creates a separate route. This becomes problematic with things like table rows where each action becomes a new route and nothing shared:</p> <pre><code>;; BAD: Creates separate handler for each row \u00d7 action combination\n(defn user-table-bad [users]\n  [:table\n   (for [user users]\n     [:tr\n      [:td (:name user)]\n      [:td\n       [::c/button\n        {:data-on-click (weave/handler [user] ; Captures user - creates unique route!\n                          (delete-user! (:id user))\n                          (weave/push-html! (user-table-bad (get-updated-users))))}\n        \"Delete\"]\n       [::c/button\n        {:data-on-click (weave/handler [user] ; Another unique route per user!\n                          (promote-user! (:id user))\n                          (weave/push-html! (user-table-bad (get-updated-users))))}\n        \"Promote\"]]])])\n\n;; With 100 users \u00d7 2 actions = 200 different routes registered!\n</code></pre>"},{"location":"reference/10_handlers/#solution-shared-handlers-with-data-call-with-","title":"Solution: Shared Handlers with <code>:data-call-with-*</code>","text":"<pre><code>;; GOOD: Only 1 handler total, regardless of number of users\n(defn user-table [users]\n  (let [handle-action (weave/handler []\n                        (let [{:keys [user-id action]} weave/*signals*]\n                          (case action\n                            \"delete\" (delete-user! user-id)\n                            \"promote\" (promote-user! user-id))\n                          (weave/push-html! (user-table (get-updated-users)))))]\n    [:table\n     (for [user users]\n       [:tr\n        [:td (:name user)]\n        [:td\n         [::c/button\n          {:data-call-with-user-id (:id user)\n           :data-call-with-action \"delete\"\n           :data-on-click handle-action}\n          \"Delete\"]\n         [::c/button\n          {:data-call-with-user-id (:id user)\n           :data-call-with-action \"promote\"\n           :data-on-click handle-action}\n          \"Promote\"]]])]))\n\n;; Only 1 handler registered total - shared across all rows and actions!\n</code></pre>"},{"location":"reference/10_handlers/#request-cancellation-with-data-call-with-","title":"Request Cancellation with <code>:data-call-with-*</code>","text":"<p>When using <code>:data-call-with-*</code> attributes, the request cancellation behavior is controlled by the handler's metadata:</p> <pre><code>(defn payment-view []\n  (let [payment-handler (weave/handler ^{:request-cancellation \"serialize\"} []\n                          (let [{:keys [action amount]} weave/*signals*]\n                            (process-payment! amount)\n                            (weave/push-html! [:div \"Payment processed\"])))]\n    [:button\n     {:data-call-with-action \"process-payment\"\n      :data-call-with-amount \"100\"\n      :data-on-click payment-handler}\n     \"Process Payment\"]))\n</code></pre> <p>The serialize behavior ensures that even with rapid clicking, only one payment operation will execute.</p>"},{"location":"reference/20_push_broadcast/","title":"Push and Broadcast","text":"<p>Weave provides several functions for updating the UI and communicating with the client browser. These functions fall into two main categories:</p> <ul> <li>Push functions: Send updates to the specific browser tab/window   that triggered the current handler</li> <li>Broadcast functions: Send updates to all browser tabs/windows   that share the same session ID</li> </ul>"},{"location":"reference/20_push_broadcast/#html-updates","title":"HTML Updates","text":""},{"location":"reference/20_push_broadcast/#push-html","title":"push-html!","text":"<p>Pushes HTML updates to the specific browser tab/window that triggered the handler.</p> <pre><code>(weave/push-html! [:div#message \"Operation completed successfully!\"])\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcast-html","title":"broadcast-html!","text":"<p>Pushes HTML updates to all browser tabs/windows that share the same session ID.</p> <pre><code>(weave/broadcast-html! [:div#notification \"New message received!\"])\n</code></pre>"},{"location":"reference/20_push_broadcast/#navigation","title":"Navigation","text":""},{"location":"reference/20_push_broadcast/#push-path","title":"push-path!","text":"<p>Changes the URL hash for the specific browser tab/window that triggered the handler. Optionally renders a new view.</p> <pre><code>;; Simple navigation\n(weave/push-path! \"/dashboard\")\n\n;; Navigation with view update\n(weave/push-path! \"/profile\" \n  (fn [] \n    [:div#profile \n     [:h1 \"User Profile\"]\n     [:p \"Profile content here\"]]))\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcast-path","title":"broadcast-path!","text":"<p>Changes the URL hash for all browser tabs/windows that share the same session ID. Optionally renders a new view.</p> <pre><code>;; Simple navigation for all tabs\n(weave/broadcast-path! \"/logout\")\n\n;; Navigation with view update for all tabs\n(weave/broadcast-path! \"/maintenance\" \n  (fn [] \n    [:div.alert \n     [:h1 \"Maintenance Mode\"]\n     [:p \"The system is currently undergoing maintenance.\"]]))\n</code></pre>"},{"location":"reference/20_push_broadcast/#javascript-execution","title":"JavaScript Execution","text":""},{"location":"reference/20_push_broadcast/#push-script","title":"push-script!","text":"<p>Sends JavaScript to the specific browser tab/window for execution.</p> <pre><code>(weave/push-script! \"console.log('Handler executed');\")\n</code></pre>"},{"location":"reference/20_push_broadcast/#push-reload","title":"push-reload!","text":"<p>Sends a reload command to the specific browser tab/window.</p> <pre><code>(weave/push-reload!)\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcast-script","title":"broadcast-script!","text":"<p>Sends JavaScript to all browser tabs/windows for execution.</p> <pre><code>(weave/broadcast-script! \"localStorage.clear();\")\n</code></pre>"},{"location":"reference/20_push_broadcast/#data-and-state","title":"Data and State","text":""},{"location":"reference/20_push_broadcast/#push-signal","title":"push-signal!","text":"<p>Sends updated signal values to the specific browser tab/window.</p> <pre><code>(weave/push-signal! {:user {:name \"John\" :role \"admin\"}})\n</code></pre> <p>Signals are client-side state values that can be accessed in the browser using Datastar.  They can be used for reactive UI updates, storing user preferences, or maintaining application state. Signals are stored in the browser and can be accessed in HTML attributes using the <code>data-signals-</code> prefix:</p> <pre><code>[:div {:data-signals-username \"''\"}\n \"Welcome, \"\n [:span {:data-text \"$username\"}]]\n\n;; Later update the signal\n(weave/push-signal! {:username \"John\"})\n</code></pre>"},{"location":"reference/20_push_broadcast/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/20_push_broadcast/#form-submission-handler","title":"Form Submission Handler","text":"<pre><code>[:form\n {:data-on-submit\n  (weave/handler ^{:type :form} []\n   (let [form-data (:params weave/*request*)]\n     (save-data! form-data)\n     (weave/push-html! \n      [:div#status.text-green-500 \"Data saved successfully!\"])))}\n [:input {:type \"text\" :name \"username\"}]\n [:button {:type \"submit\"} \"Save\"]]\n</code></pre>"},{"location":"reference/20_push_broadcast/#toggling-ui-elements","title":"Toggling UI Elements","text":"<pre><code>(let [panel-visible (atom false)]\n  [:button\n   {:data-on-click\n    (weave/handler [panel-visible]\n     (weave/push-html!\n      [:div#panel\n       {:class (if @panel-visible \"hidden\" \"block\")}\n       \"Panel content\"])\n     (swap! panel-visible not))}\n   \"Toggle Panel\"])\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcasting-notifications","title":"Broadcasting Notifications","text":"<pre><code>(defn notify-all-users [message]\n  (weave/broadcast-html!\n   [:div#notification.fixed.top-0.right-0.m-4.p-4.bg-blue-500.text-white.rounded\n    {:data-on-load\n     (weave/handler []\n      (weave/push-script!\n       \"setTimeout(() =&gt; document.getElementById('notification').remove(), 5000)\"))}\n    message]))\n</code></pre>"},{"location":"reference/25_views/","title":"Views","text":"<p>The <code>weave.view</code> namespace provides a DSL for defining and switching between views with URL-based routing. Views are encoded in the URL hash using Transit-MessagePack, allowing for bookmarkable and shareable URLs.</p>"},{"location":"reference/25_views/#creating-a-view-registry","title":"Creating a View Registry","text":"<p>Use <code>view/new</code> to create a view registry with an id and optional default view:</p> <pre><code>(require '[weave.view :as view])\n\n(def views\n  (-&gt; (view/new {:id :content\n                 :default :welcome})\n      (view/add {:id :welcome\n                 :render #'welcome-view})\n      (view/add {:id :users\n                 :render #'users-view})\n      (view/add {:id :user-edit\n                 :signals {:loading false}\n                 :render #'user-edit-view})))\n</code></pre>"},{"location":"reference/25_views/#options","title":"Options","text":"<ul> <li><code>:id</code> - keyword, required<ul> <li>Identifies the view registry in the URL</li> <li>Used as the <code>id</code> attribute of the container <code>div</code> where views  render</li> </ul> </li> <li><code>:default</code> - keyword, optional - view to render when URL has no   encoded path for the view</li> </ul> <p>The rendered output wraps your view in a div with the views id:</p> <pre><code>(def views (view/new {:id :content :default :home}))\n\n;; (view/render views) produces:\n[:div {:id :content} (view-renderer)]\n</code></pre>"},{"location":"reference/25_views/#view-definition","title":"View Definition","text":"<p>Each view added with <code>view/add</code> takes a map with:</p> <ul> <li><code>:id</code> - keyword, required - unique identifier for the view</li> <li><code>:render</code> - function or var, required - receives the view registry   as its argument and returns hiccup for the view</li> <li><code>:signals</code> - map, optional - default signal values namespaced under   the view id</li> </ul>"},{"location":"reference/25_views/#rendering-views","title":"Rendering Views","text":"<p>Call <code>view/render</code> with just the view to render based on the current URL:</p> <pre><code>(defn main-view []\n  [:div#app\n   [:nav\n    [:button {:href (view/href views :users)\n              :data-on-click (weave/handler [views]\n                               (view/render views :users))}\n     \"Users\"]]\n   (view/render views)])\n</code></pre>"},{"location":"reference/25_views/#navigating-to-views","title":"Navigating to Views","text":"<p>Call <code>view/render</code> with a view id to navigate:</p> <pre><code>;; Navigate to :users view\n(view/render views :users)\n\n;; Navigate with params\n(view/render views :user-edit {:id 123})\n</code></pre> <p>This pushes the new URL hash and updates the container element.</p>"},{"location":"reference/25_views/#generating-urls","title":"Generating URLs","text":"<p>Use <code>view/href</code> to generate URLs for links. The views must be passed as the first argument:</p> <pre><code>(view/href views :users)\n;; =&gt; \"/#/kpY...\"\n\n(view/href views :user-edit {:id 123})\n;; =&gt; \"/#/k5YB...\"\n</code></pre>"},{"location":"reference/25_views/#multi-view-support","title":"Multi-View Support","text":"<p>Multiple view registries can share the same URL, each maintaining independent state. The URL encodes a map of registry id to <code>[view-id params]</code>:</p> <pre><code>(def sidebar-views\n  (-&gt; (view/new {:id :sidebar\n                 :default :nav})\n      (view/add {:id :nav :render #'nav-view})\n      (view/add {:id :settings :render #'settings-view})))\n\n(def content-views\n  (-&gt; (view/new {:id :content\n                 :default :dashboard})\n      (view/add {:id :dashboard :render #'dashboard-view})\n      (view/add {:id :users :render #'users-view})))\n\n(defn main-view []\n  [:div#app\n   (view/render sidebar-views)\n   (view/render content-views)])\n</code></pre> <p>When rendering a non-default view, each registry's state is preserved in the URL independently. Default views are omitted from the URL to keep URLs minimal.</p>"},{"location":"reference/25_views/#url-optimization","title":"URL Optimization","text":"<p>When a view registry is at its default view with no params, it is excluded from the URL entirely:</p> <pre><code>;; If sidebar is at :nav (default) and content is at :users\n;; Only content state is encoded in URL\n(view/href content-views :users)\n;; =&gt; \"/#/kpY...\" (encodes {:content [:users {}]})\n\n;; If both are at defaults\n;; URL is clean with no encoded state\n;; =&gt; \"/#/\"\n</code></pre>"},{"location":"reference/25_views/#signals","title":"Signals","text":"<p>Views can define default signals that are namespaced under the view id. This prevents signal collisions between views.</p> <pre><code>(def views\n  (-&gt; (view/new {:id :content})\n      (view/add {:id :search\n                 :signals {:query \"\" :page 0}\n                 :render #'search-view})))\n</code></pre> <p>The signals are accessible as <code>search.query</code> and <code>search.page</code> in datastar attributes:</p> <pre><code>(defn search-view [_views]\n  [:div\n   [:input {:data-bind-search.query true\n            :placeholder \"Search...\"}]\n   [:span {:data-text \"$search.page\"}]])\n</code></pre>"},{"location":"reference/25_views/#accessing-signals-in-clojure","title":"Accessing Signals in Clojure","text":"<p>Since signals are namespaced under the view id, access them via <code>weave/*signals*</code> using the nested structure:</p> <pre><code>(defn search-view [_views]\n  (let [{:keys [query page]} (:search weave/*signals*)]\n    [:div\n     [:p (str \"Searching for: \" query)]\n     [:p (str \"Page: \" page)]]))\n</code></pre>"},{"location":"reference/25_views/#setting-signals-in-clojure","title":"Setting Signals in Clojure","text":"<p>Use <code>weave/push-signal!</code> with the nested structure:</p> <pre><code>;; Set a single signal\n(weave/push-signal! {:search {:query \"hello\"}})\n\n;; Set multiple signals\n(weave/push-signal! {:search {:query \"hello\" :page 1}})\n</code></pre>"},{"location":"reference/25_views/#resetting-signals","title":"Resetting Signals","text":"<p>Use <code>view/reset-signals!</code> to reset a view's signals to their defaults:</p> <pre><code>(view/reset-signals! views :search)\n;; Pushes {:search {:query \"\" :page 0}} to client\n</code></pre>"},{"location":"reference/25_views/#url-format","title":"URL Format","text":"<p>Views are encoded in the URL hash as base64 Transit-MessagePack:</p> <pre><code>/#/&lt;base64-encoded-data&gt;\n</code></pre> <p>The encoded data is a map of <code>{views-id [view-id params-map]}</code>. This format:</p> <ul> <li>Supports multiple independent view registries in one URL</li> <li>Is compact and URL-safe</li> <li>Supports complex params (keywords, nested maps, etc.)</li> <li>Is bookmarkable and shareable</li> <li>Omits views at their default state for clean URLs</li> </ul>"},{"location":"reference/25_views/#getting-the-current-path","title":"Getting the Current Path","text":"<p>Use <code>view/path</code> to get the current view path as <code>[view-id params-map]</code>. This works both during rendering and in handlers:</p> <pre><code>(defn user-edit-view [views]\n  (let [[_view-id {:keys [id]}] (view/path views)]\n    [:div\n     [:h1 (str \"Editing User \" id)]]))\n</code></pre>"},{"location":"reference/25_views/#complete-example","title":"Complete Example","text":"<pre><code>(ns myapp.core\n  (:require [weave.core :as weave]\n            [weave.view :as view]))\n\n(defn welcome-view [_views]\n  [:div.text-center\n   [:h1 \"Welcome\"]\n   [:p \"Select a page from the navigation\"]])\n\n(defn users-view [views]\n  [:div\n   [:h1 \"Users\"]\n   [:ul\n    (for [user @users-atom]\n      [:li {:key (:id user)}\n       [:a {:href (view/href views :user-edit {:id (:id user)})}\n        (:name user)]])]])\n\n(defn user-edit-view [views]\n  (let [[_view-id {:keys [id]}] (view/path views)]\n    [:div\n     [:h1 \"Edit User\"]\n     [:p (str \"Editing user: \" id)]\n     [:button {:data-on-click (weave/handler [views]\n                                (view/render views :users))}\n      \"Back to Users\"]]))\n\n(def views\n  (-&gt; (view/new {:id :content\n                 :default :welcome})\n      (view/add {:id :welcome\n                 :render #'welcome-view})\n      (view/add {:id :users\n                 :render #'users-view})\n      (view/add {:id :user-edit\n                 :render #'user-edit-view})))\n\n(defn main-view []\n  [:div#app\n   [:nav.flex.gap-4.p-4\n    [:button\n     {:href (view/href views :users)\n      :data-on-click (weave/handler [views]\n                       (view/render views :users))}\n     \"Users\"]\n    [:button\n     {:href (view/href views :user-edit {:id 1})\n      :data-on-click (weave/handler [views]\n                       (view/render views :user-edit {:id 1}))}\n     \"Edit User 1\"]]\n\n   (view/render views)])\n</code></pre>"},{"location":"reference/30_session/","title":"Session Management","text":"<p>Weave provides a session management system that handles authentication, CSRF protection, and server-sent event (SSE) connections.</p>"},{"location":"reference/30_session/#how-sessions-work-in-weave","title":"How Sessions Work in Weave","text":"<p>Weave's session system uses three cookies to manage user state:</p> <ol> <li>weave-sid: The session ID cookie that uniquely identifies a browser session</li> <li>weave-csrf: A CSRF token that protects against cross-site request forgery attacks</li> <li>weave-auth: A JWT (JSON Web Token) that stores authenticated user information</li> </ol>"},{"location":"reference/30_session/#session-flow","title":"Session Flow","text":"<ol> <li> <p>When a user first visits a Weave application:</p> <ul> <li>A unique session ID is generated</li> <li>A CSRF token is derived from this session ID</li> <li>Both are set as cookies in the browser</li> </ul> </li> <li> <p>For authenticated sessions:</p> <ul> <li>When a user signs in, their identity information is stored in a JWT</li> <li>The JWT is set as the <code>weave-auth</code> cookie</li> <li>Subsequent requests include this cookie, allowing the server to   verify the user's identity</li> </ul> </li> <li> <p>For all requests:</p> <ul> <li>The CSRF token must be included in the <code>x-csrf-token</code> header</li> <li>The server verifies that the CSRF token matches the expected   value for the session ID</li> <li>If valid, the request proceeds; otherwise, it's rejected with a   403 status</li> </ul> </li> </ol>"},{"location":"reference/30_session/#managing-connections","title":"Managing Connections","text":"<p>Weave tracks active browser connections using a combination of session ID and instance ID:</p> <ul> <li>Each browser tab/window gets a unique instance ID</li> <li>Multiple tabs can share the same session ID</li> <li>This allows Weave to:</li> <li>Push updates to specific tabs (<code>push-html!</code>)</li> <li>Broadcast to all tabs for a user (<code>broadcast-html!</code>)</li> </ul>"},{"location":"reference/30_session/#session-management-functions","title":"Session Management Functions","text":""},{"location":"reference/30_session/#authentication","title":"Authentication","text":"<pre><code>;; Sign in a user and get the auth cookie string\n(weave/set-cookie! (session/sign-in {:name \"username\" :role \"admin\"}))\n\n;; Sign out a user by clearing the auth cookie\n(weave/set-cookie! (session/sign-out))\n</code></pre>"},{"location":"reference/30_session/#using-set-cookie","title":"Using <code>set-cookie!</code>","text":"<p>The <code>set-cookie!</code> function is a key part of session management in Weave. The function works by sending JavaScript that sets the document.cookie value, which updates or creates the specified cookie in the browser.</p> <pre><code>;; Basic usage\n(weave/set-cookie! \"mycookie=value; Path=/; Max-Age=86400\")\n\n;; Sign in example\n(weave/handler []\n  (weave/set-cookie! \n    (session/sign-in {:name \"Weave\" :role \"User\"}))\n  (weave/push-reload!))\n\n;; Sign out example\n(weave/handler []\n  (weave/set-cookie! (session/sign-out))\n  (weave/push-path! \"/sign-in\"))\n</code></pre>"},{"location":"reference/30_session/#session-activity-tracking","title":"Session Activity Tracking","text":"<p>Weave automatically tracks the last activity timestamp for each session instance whenever a handler is called. This enables you to:</p> <ol> <li>Monitor when users were last active</li> <li>Automatically logout stale sessions</li> <li>Build features like \"active users\" displays</li> </ol>"},{"location":"reference/30_session/#activity-tracking-functions","title":"Activity Tracking Functions","text":"<pre><code>(require '[weave.session :as session])\n\n;; Get the last activity timestamp for a specific session instance\n(session/last-activity session-id instance-id)\n;; =&gt; 1672531200000 (timestamp in milliseconds)\n\n;; Get all activity data for a session\n;; Returns a map of {instance-id -&gt; timestamp}\n(session/session-activity session-id)\n;; =&gt; {\"instance-123\" 1672531200000, \"instance-456\" 1672531150000}\n\n;; Get all session activity data\n;; Returns a map of {session-id -&gt; {instance-id -&gt; timestamp}}\n(session/session-activities)\n;; =&gt; {\"session-abc\" {\"instance-123\" 1672531200000}\n;;     \"session-def\" {\"instance-456\" 1672531150000}}\n\n;; Get activity data for a specific session\n;; Returns a map of {instance-id -&gt; timestamp}\n(session/session-activities \"session-abc\")\n;; =&gt; {\"instance-123\" 1672531200000}\n</code></pre>"},{"location":"reference/30_session/#configuration","title":"Configuration","text":"<p>When starting a Weave application, you can configure session security:</p> <pre><code>(weave/run view-fn \n  {:csrf-secret \"your-csrf-secret\"  ;; Secret for CSRF token generation\n   :jwt-secret \"your-jwt-secret\"})  ;; Secret for JWT signing\n</code></pre> <p>If not provided, Weave will generate random secrets for each server instance.</p>"},{"location":"reference/40_javascript/","title":"JavaScript","text":"<p>Weave provides JavaScript interoperability through Squint, a lightweight Clojure-to-JavaScript transpiler. This allows you to write Clojure code that gets converted to JavaScript for client-side execution.</p>"},{"location":"reference/40_javascript/#how-javascript-support-works","title":"How JavaScript Support Works","text":"<p>Weave uses Squint to:</p> <ol> <li>Transpile Clojure code to JavaScript at runtime</li> <li>Execute the generated JavaScript in the browser</li> <li>Integrate with the DOM and browser APIs</li> </ol> <p>This approach gives you the expressiveness of Clojure with direct access to browser capabilities.</p>"},{"location":"reference/40_javascript/#using-javascript-in-weave","title":"Using JavaScript in Weave","text":"<p>There are several ways to use JavaScript in Weave:</p>"},{"location":"reference/40_javascript/#1-inline-scripts-with-push-script","title":"1. Inline Scripts with <code>push-script!</code>","text":"<p>The simplest way to execute JavaScript is with <code>push-script!</code>:</p> <pre><code>(weave/push-script!\n  (squint/clj-&gt;js\n    (js/alert \"Hello from Clojure!\")))\n</code></pre> <p>This transpiles the Clojure code to JavaScript and sends it to the current browser tab for execution.</p>"},{"location":"reference/40_javascript/#2-broadcasting-scripts-to-all-sessions","title":"2. Broadcasting Scripts to All Sessions","text":"<p>To send JavaScript to all connected browser tabs for the current user:</p> <pre><code>(weave/broadcast-script!\n  (squint/clj-&gt;js\n    (js/console.log \"This appears in all tabs\")))\n</code></pre>"},{"location":"reference/40_javascript/#3-event-handlers-with-javascript","title":"3. Event Handlers with JavaScript","text":"<p>You can combine DOM updates with JavaScript execution:</p> <pre><code>{:data-on-click\n (weave/handler []\n  ;; Update the DOM\n  (weave/push-html! [:div#status \"Processing...\"])\n\n  ;; Execute JavaScript\n  (weave/push-script!\n   (squint/clj-&gt;js\n    (let [result (js/fetch \"/api/data\")]\n      (.then result #(.json %))\n      (.then result #(js/console.log \"Data received:\" %))\n      (.catch result #(js/console.error \"Error:\" %))))))}\n</code></pre>"},{"location":"reference/40_javascript/#4-dom-manipulation","title":"4. DOM Manipulation","text":"<p>You can directly manipulate the DOM:</p> <pre><code>(weave/push-script!\n (squint/clj-&gt;js\n  (let [element (js/document.getElementById \"counter\")]\n    (set! (.-textContent element) \n          (inc (js/parseInt (.-textContent element)))))))\n</code></pre>"},{"location":"reference/40_javascript/#the-clj-js-macro","title":"The <code>clj-&gt;js</code> Macro","text":"<p>The <code>clj-&gt;js</code> macro is the primary tool for JavaScript interoperability:</p> <pre><code>(weave/push-script!\n (squint/clj-&gt;js\n  (defn greet [name]\n    (js/alert (str \"Hello, \" name \"!\")))\n\n  (greet \"World\")))\n</code></pre> <p>This transpiles the Clojure code to JavaScript and executes it in the browser.</p> <p>The <code>clj-&gt;js</code> macro accepts an optional map of options:</p> <pre><code>(weave/push-script!\n (clj-&gt;js\n  {:elide-imports true\n   :elide-exports true\n   :top-level false\n   :context :expr\n   :core-alias \"squint.core\"}\n\n  (defn advanced-example []\n    (js/console.log \"Custom options\"))\n\n  (advanced-example)))\n</code></pre>"},{"location":"reference/40_javascript/#limitations-and-differences-from-clojurescript","title":"Limitations and Differences from ClojureScript","text":"<p>While Squint provides excellent JavaScript interoperability, it's important to understand its limitations:</p> <ol> <li>Not Full ClojureScript: Squint is a lightweight transpiler, not a complete ClojureScript implementation</li> <li>Different Data Structures: Squint maps to JavaScript primitives</li> <li>Limited Standard Library: Only a subset of Clojure's core functions are available</li> <li>No Advanced Optimizations: Unlike ClojureScript, there's no advanced compilation or optimization</li> <li>Runtime Transpilation: Code is transpiled at runtime, not ahead-of-time</li> </ol>"},{"location":"reference/40_javascript/#example-timer-application","title":"Example: Timer Application","text":"<p>Here's a complete example of a timer application using JavaScript interoperability:</p> <pre><code>(defn timer-view []\n  [:div.p-6\n   [:h1#timer.text-4xl.font-bold \"0\"]\n   [:div.flex.gap-2.mt-4\n    [:button.bg-green-500.text-white.px-4.py-2.rounded\n     {:data-on-click\n      (weave/handler []\n       (weave/push-script!\n        (squint/clj-&gt;js\n         (let [interval-id (js/setInterval\n                            (fn []\n                              (let [timer (js/document.getElementById \"timer\")\n                                    current (js/parseInt (.-textContent timer))]\n                                (set! (.-textContent timer) (inc current))))\n                            1000)]\n           (set! (.. js/window -weaveTimerId) interval-id)))))}\n     \"Start\"]\n\n    [:button.bg-red-500.text-white.px-4.py-2.rounded\n     {:data-on-click\n      (weave/handler []\n       (weave/push-script!\n        (squint/clj-&gt;js\n         (when (.. js/window -weaveTimerId)\n           (js/clearInterval (.. js/window -weaveTimerId))\n           (set! (.. js/window -weaveTimerId) nil)))))}\n     \"Stop\"]\n\n    [:button.bg-blue-500.text-white.px-4.py-2.rounded\n     {:data-on-click\n      (weave/handler []\n       (weave/push-script!\n        (squint/clj-&gt;js\n         (let [timer (js/document.getElementById \"timer\")]\n           (set! (.-textContent timer) \"0\")))))}\n     \"Reset\"]]])\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Setting up a JavaScript interval timer</li> <li>Storing state in a browser window property</li> <li>Manipulating the DOM directly</li> <li>Cleaning up resources when stopping the timer</li> </ul>"},{"location":"reference/45_custom_routes/","title":"Custom Routes","text":"<p>Weave allows you to define custom routes to handle requests outside of the standard Weave event system. This is useful for creating API endpoints, handling file uploads, or integrating with external services.</p>"},{"location":"reference/45_custom_routes/#adding-custom-routes","title":"Adding Custom Routes","text":"<p>Custom routes are added through the <code>:handlers</code> option when starting your Weave application. These routes use Compojure syntax and are merged with Weave's internal routes.</p> <pre><code>(weave/run view-fn\n  {:handlers [(GET \"/api/data\" request (api-handler request))\n              (POST \"/api/upload\" request (upload-handler request))\n              (GET \"/api/download/:id\" [id :as request] (download-handler id request))]})\n</code></pre>"},{"location":"reference/45_custom_routes/#route-handlers","title":"Route Handlers","text":"<p>Route handlers are regular Ring handler functions that take a request map and return a response map:</p> <pre><code>(defn api-handler [request]\n  {:status 200\n   :headers {\"Content-Type\" \"application/json\"}\n   :body \"{\\\"message\\\":\\\"Hello from API\\\"}\"})\n\n(defn download-handler [id request]\n  {:status 200\n   :headers {\"Content-Type\" \"application/octet-stream\"}\n   :body (get-file-by-id id)})\n</code></pre>"},{"location":"reference/45_custom_routes/#authentication-for-custom-routes","title":"Authentication for Custom Routes","text":"<p>Custom routes don't automatically use Weave's authentication system. To protect your routes, you need to manually check the request for authentication information,</p> <pre><code>(defn authenticated-api [request]\n  (if (:identity request)\n    {:status 200\n     :headers {\"Content-Type\" \"application/json\"}\n     :body \"{\\\"data\\\":\\\"Protected data\\\"}\"}\n    {:status 403\n     :headers {\"Content-Type\" \"application/json\"}\n     :body \"{\\\"error\\\":\\\"Unauthorized\\\"}\"}))\n</code></pre>"},{"location":"reference/45_custom_routes/#accessing-weave-context","title":"Accessing Weave Context","text":"<p>Custom routes have access to the same request context as Weave handlers, including session information:</p> <pre><code>(defn session-info [request]\n  (let [session-id (session/get-sid request)]\n    {:status 200\n     :headers {\"Content-Type\" \"application/json\"}\n     :body (str \"{\\\"session\\\":\\\"\" session-id \"\\\"}\")}))\n</code></pre>"},{"location":"reference/50_pwa/","title":"Progressive Web Apps (PWA)","text":"<p>Weave includes built-in support for Progressive Web Apps (PWAs), allowing your applications to be installed on devices and provide a more app-like experience.</p>"},{"location":"reference/50_pwa/#pwa-support-in-weave","title":"PWA Support in Weave","text":"<p>Weave automatically generates and serves the necessary resources for PWAs:</p> <ol> <li>Web App Manifest: A JSON file that tells the browser about your    application</li> <li>Icons: Various sized icons for different devices and contexts</li> </ol> <p>Note: Currently, Weave does not automatically generate a service worker, which is required for full PWA functionality like offline support. If you need offline capabilities, you'll need to implement a custom service worker and register it in your application.</p>"},{"location":"reference/50_pwa/#configuration","title":"Configuration","text":"<p>To enable PWA features in your Weave application, provide an <code>:icon</code> path and optional <code>:pwa</code> configuration when starting your application:</p> <pre><code>(weave/run view-fn\n  {:title \"My PWA App\"\n   :icon \"public/my-icon.png\"  ;; Path to an icon in your classpath\n   :pwa {:name \"My PWA App\"\n         :short-name \"MyApp\"\n         :description \"A description of my application\"\n         :display \"standalone\"\n         :background-color \"#f2f2f2\"\n         :theme-color \"#4a86e8\"\n         :start-url \"/\"}})\n</code></pre>"},{"location":"reference/50_pwa/#icon-requirements","title":"Icon Requirements","text":"<p>The icon you provide should be:</p> <ul> <li>A PNG image</li> <li>High resolution (at least 512x512 pixels recommended)</li> <li>Located in your classpath (typically in resources directory)</li> </ul> <p>Weave will automatically resize your icon to create:</p> <ul> <li><code>/favicon.png</code> (32x32) - For browser tabs</li> <li><code>/icon-180.png</code> (180x180) - For iOS home screens</li> <li><code>/icon-192.png</code> (192x192) - For Android home screens</li> <li><code>/icon-512.png</code> (512x512) - For high-resolution displays</li> </ul>"},{"location":"reference/50_pwa/#web-app-manifest-options","title":"Web App Manifest Options","text":"<p>The <code>:pwa</code> configuration map supports these options:</p> Option Description Default <code>:name</code> Full application name Value of <code>:title</code> option <code>:short-name</code> Short name for app icons Same as <code>:name</code> <code>:description</code> App description None <code>:display</code> Display mode <code>\"standalone\"</code> <code>:background-color</code> Background color during loading <code>\"#f2f2f2\"</code> <code>:theme-color</code> Theme color for browser UI <code>\"#ffffff\"</code> <code>:start-url</code> URL to load when app launches <code>\"/\"</code>"},{"location":"reference/50_pwa/#testing-your-pwa","title":"Testing Your PWA","text":"<p>Modern browsers provide tools to test PWA functionality:</p> <ol> <li>In Chrome, open DevTools and go to the \"Application\" tab</li> <li>Check the \"Manifest\" section to verify your web app manifest</li> <li>Use Lighthouse (in the \"Audits\" tab) to test PWA compliance</li> </ol>"},{"location":"reference/50_pwa/#installation-experience","title":"Installation Experience","text":"<p>When users visit your Weave application in a supported browser:</p> <ol> <li>After some engagement, the browser may show an \"Add to Home Screen\" prompt</li> <li>Users can also manually install the app through the browser menu</li> <li>Once installed, the app will appear on the device's home screen or app launcher</li> <li>When launched, it will open in a standalone window without browser UI</li> </ol>"},{"location":"reference/50_pwa/#push-notifications","title":"Push Notifications","text":""},{"location":"reference/50_pwa/#setup","title":"Setup","text":"<ol> <li>Generate VAPID keys (once, store securely):</li> </ol> <pre><code>(require '[weave.push :as push])\n\n(push/generate-vapid-keypair)\n;; =&gt; {:public-key \"BEl62i...\" :private-key \"...\"}\n</code></pre> <ol> <li>Define push options:</li> </ol> <pre><code>(def subscriptions (atom {}))\n\n(def push-opts\n  {:vapid-public-key  (System/getenv \"VAPID_PUBLIC_KEY\")\n   :vapid-private-key (System/getenv \"VAPID_PRIVATE_KEY\")\n   :vapid-subject     \"mailto:admin@example.com\"\n   :save-subscription!    (fn [id subscription]\n                            (swap! subscriptions assoc id subscription))\n   :delete-subscription!  (fn [id endpoint]\n                            (swap! subscriptions dissoc id))\n   :get-subscriptions     (fn [id]\n                            (when-let [sub (get @subscriptions id)]\n                              [sub]))})\n</code></pre> <ol> <li>Start server with push enabled:</li> </ol> <pre><code>(weave/run my-view\n  {:icon \"public/icon.png\"\n   :push push-opts})\n</code></pre>"},{"location":"reference/50_pwa/#client-side-subscription","title":"Client-Side Subscription","text":"<p>Use the <code>weave.push</code> JavaScript API to subscribe users:</p> <pre><code>;; Session-based (default)\n[::c/button\n {:data-on-click (weave/handler []\n                   (weave/push-script!\n                    \"weave.push.subscribe()\"))}\n \"Enable Notifications\"]\n\n;; User-based (pass user ID)\n[::c/button\n {:data-on-click (weave/handler []\n                   (let [user-id (get-in weave/*request* [:identity :id])]\n                     (weave/push-script!\n                      (str \"weave.push.subscribe('\" user-id \"')\"))))}\n \"Enable Notifications\"]\n</code></pre> <p>Available JavaScript functions:</p> Function Description <code>weave.push.isSupported()</code> Check if browser supports push <code>weave.push.getPermission()</code> Get current permission state <code>weave.push.isSubscribed()</code> Check if currently subscribed <code>weave.push.subscribe(id?)</code> Subscribe (optional id, defaults to session) <code>weave.push.unsubscribe(id?)</code> Unsubscribe (optional id, defaults to session)"},{"location":"reference/50_pwa/#sending-notifications","title":"Sending Notifications","text":"<p>Use <code>push/send!</code> to send notifications:</p> <pre><code>;; From a background job\n(push/send! \"user-123\"\n            {:title \"New Message\"\n             :body \"You have a new message from Alice\"\n             :url \"/#/messages\"}\n            push-opts)\n</code></pre>"},{"location":"reference/50_pwa/#notification-payload","title":"Notification Payload","text":"Field Description <code>:title</code> Notification title (required) <code>:body</code> Body text <code>:url</code> URL to open when clicked <code>:icon</code> Icon URL <code>:badge</code> Badge icon URL <code>:tag</code> Tag for grouping notifications <code>:data</code> Additional data for the service worker"},{"location":"reference/60_components/","title":"Components","text":"<p>Weave provides a collection of pre-styled UI components through the <code>weave.components</code> namespace. These components help you build consistent, attractive interfaces without writing extensive CSS or HTML markup.</p>"},{"location":"reference/60_components/#overview","title":"Overview","text":"<p>The components namespace offers themed, pre-styled UI elements that follow modern design principles. These components are built on top of Tailwind CSS and are designed to work seamlessly with Weave's server-side rendering approach.</p>"},{"location":"reference/60_components/#usage","title":"Usage","text":"<p>To use Weave components, require the namespace in your application:</p> <pre><code>(ns your-app.core\n  (:require [weave.components :as c]))\n</code></pre> <p>Then use the components in your views with the namespace keyword syntax:</p> <pre><code>(defn my-view []\n  [::c/view#app\n   [::c/card\n    [:h1.text-2xl \"Hello World\"]\n    [::c/button {:variant :primary} \"Click Me\"]]])\n</code></pre>"},{"location":"reference/60_components/#component-customization","title":"Component Customization","text":"<p>Most components accept options as a map of attributes:</p> <pre><code>[::c/button \n {:variant :primary    ; Visual style\n  :size :lg            ; Size variant\n  :disabled true       ; State\n  :class \"mt-4\"}       ; Additional classes\n \"Submit\"]\n</code></pre>"},{"location":"reference/60_components/#work-in-progress","title":"Work in Progress","text":"<p>The components namespace is a work in progress. New components are being added regularly, and existing components may evolve based on user feedback and best practices.</p> <p>Future plans include: - More specialized components for data visualization - Enhanced theming capabilities - Responsive design improvements - Accessibility enhancements</p> <p>For the most up-to-date information on available components, refer to the source code or examples in the demo application.</p>"},{"location":"reference/70_resources/","title":"Bundling Resources","text":"<p>Weave comes bundled with several frontend resources to make building web applications easier. These resources are served from the classpath and are available to your application without any additional configuration.</p>"},{"location":"reference/70_resources/#bundled-resources","title":"Bundled Resources","text":""},{"location":"reference/70_resources/#tailwind-css","title":"Tailwind CSS","text":"<p>Tailwind CSS v3.4.16 is included by default. It provides a utility-first CSS framework. You can use Tailwind classes directly in your Hiccup markup:</p> <pre><code>[:div.flex.items-center.justify-between.p-4.bg-white.shadow\n [:h1.text-xl.font-bold \"My Application\"]\n [:button.px-4.py-2.bg-blue-500.text-white.rounded.hover:bg-blue-600\n  \"Click Me\"]]\n</code></pre> <p>Tailwind is enabled by default, but you can disable it if you prefer to use your own CSS framework:</p> <pre><code>(weave/run view-fn\n  {:tailwind false})\n</code></pre>"},{"location":"reference/70_resources/#datastar","title":"Datastar","text":"<p>Datastar v1.0.0-RC.5 is included for client-side reactivity and event handling. Weave uses Datastar internally for its event system and server-sent events (SSE) communication.</p>"},{"location":"reference/70_resources/#squint","title":"Squint","text":"<p>Squint v0.9.182 is included for JavaScript interoperability, allowing you to write Clojure code that gets transpiled to JavaScript for client-side execution.</p>"},{"location":"reference/70_resources/#heroicons","title":"Heroicons","text":"<p>Weave includes Heroicons as an SVG sprite, making it easy to use these popular icons in your application. The icons are accessible through the <code>::icon</code> component in the <code>weave.components</code> namespace:</p> <pre><code>(ns your-app.core\n  (:require [weave.components :as c]))\n\n(defn view []\n  [:div\n   [::c/icon#solid-home {:class \"h-6 w-6 text-blue-500\"}]\n   [::c/icon#solid-user {:class \"h-6 w-6 text-green-500\"}]\n   [::c/icon#solid-cog {:class \"h-6 w-6 text-gray-500\"}]])\n</code></pre> <p>The icon ID format is <code>#[style]-[name]</code> where:</p> <ul> <li><code>style</code> is either <code>solid</code> or <code>outline</code></li> <li><code>name</code> is the icon name from Heroicons (e.g., <code>home</code>, <code>user</code>, <code>cog</code>)</li> </ul> <p>You can customize the size and color of icons using Tailwind classes.</p>"},{"location":"reference/70_resources/#serving-custom-resources","title":"Serving Custom Resources","text":"<p>You can serve your own static resources by placing them in the <code>resources/public</code> directory of your project. Files in this directory will be automatically served at the root path of your application.</p> <p>For example:</p> <pre><code>your-project/\n\u251c\u2500\u2500 resources/\n\u2502   \u2514\u2500\u2500 public/\n\u2502       \u251c\u2500\u2500 css/\n\u2502       \u2502   \u2514\u2500\u2500 custom.css\n\u2502       \u251c\u2500\u2500 js/\n\u2502       \u2502   \u2514\u2500\u2500 app.js\n\u2502       \u2514\u2500\u2500 images/\n\u2502           \u2514\u2500\u2500 logo.png\n</code></pre> <p>These files would be accessible at:</p> <ul> <li><code>http://localhost:8080/css/custom.css</code></li> <li><code>http://localhost:8080/js/app.js</code></li> <li><code>http://localhost:8080/images/logo.png</code></li> </ul>"},{"location":"reference/70_resources/#using-custom-resources","title":"Using Custom Resources","text":"<p>To use your custom resources in your application:</p> <pre><code>(weave/run view-fn\n  {:head\n   [[:link {:rel \"stylesheet\" :href \"/css/custom.css\"}]\n    [:script {:src \"/js/app.js\"}]]})\n</code></pre> <pre><code>(defn view []\n  [:div\n   [:img {:src \"/images/logo.png\" :alt \"Logo\"}]])\n</code></pre>"},{"location":"reference/90_running/","title":"Running Applications","text":"<p>The <code>weave.core/run</code> function is the main entry point for starting a Weave application. It creates and starts an integrated web server with all the necessary components for your application.</p>"},{"location":"reference/90_running/#basic-usage","title":"Basic Usage","text":"<pre><code>(ns my-app.core\n  (:require [weave.core :as weave]))\n\n(defn my-view []\n  [:div\n   [:h1 \"Hello, Weave!\"]\n   [:p \"Welcome to my application\"]])\n\n(defn -main []\n  (weave/run my-view {}))\n</code></pre>"},{"location":"reference/90_running/#function-signature","title":"Function Signature","text":"<pre><code>(run view options)\n</code></pre> <p>Parameters:</p> <ul> <li><code>view</code> - A function that returns the Hiccup view to render</li> <li><code>options</code> - A map of server configuration options</li> </ul> <p>Returns:</p> <ul> <li>An integrant system that can be halted with <code>(integrant.core/halt! system)</code></li> </ul>"},{"location":"reference/90_running/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/90_running/#base-path-base-path","title":"Base Path (<code>:base-path</code>)","text":"<p>By default, Weave serves the application shell from the root path (<code>/</code>). Use <code>:base-path</code> to serve the app from a subfolder.</p> <pre><code>(weave/run my-view\n  {:base-path \"/app\"})\n</code></pre> <p>With this configuration:</p> <ul> <li><code>/</code> - Returns 404 (or can be handled by a custom handler or static resource)</li> <li><code>/app</code> - Serves the Weave application</li> <li><code>/app/#/dashboard</code> - Example client-side route within the Weave app</li> </ul> <p>Note: Only the app route is affected by <code>:base-path</code>. Static resources, <code>/app-loader</code>, <code>/h/*</code> handlers, <code>/health</code>, and other routes remain at root.</p> <p>Example with landing page:</p> <pre><code>(require '[compojure.core :refer [GET]])\n\n(weave/run my-view\n  {:base-path \"/app\"\n   :handlers [(GET \"/\" []\n               {:status 200\n                :headers {\"Content-Type\" \"text/html\"}\n                :body \"&lt;html&gt;&lt;body&gt;&lt;a href='/app'&gt;Launch App&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;\"})]})\n</code></pre>"},{"location":"reference/90_running/#http-server-options-http-kit","title":"HTTP Server Options (<code>:http-kit</code>)","text":"<pre><code>(weave/run my-view\n  {:http-kit {:bind \"127.0.0.1\"  ; IP address to bind to (default: \"0.0.0.0\")\n              :port 3000}})      ; HTTP server port (default: 8080)\n</code></pre>"},{"location":"reference/90_running/#nrepl-server-options-nrepl","title":"nREPL Server Options (<code>:nrepl</code>)","text":"<pre><code>(weave/run my-view\n  {:nrepl {:bind \"127.0.0.1\"     ; IP address to bind to (default: \"0.0.0.0\")\n           :port 7888}})         ; nREPL server port (default: 8888)\n</code></pre>"},{"location":"reference/90_running/#server-sent-events-options-sse","title":"Server-Sent Events Options (<code>:sse</code>)","text":"<pre><code>(weave/run my-view\n  {:sse {:enabled true          ; Whether to enable SSE (default: true)\n         :keep-alive false}})   ; Keep SSE connections alive when tab is hidden (default: false)\n</code></pre>"},{"location":"reference/90_running/#page-configuration","title":"Page Configuration","text":"<pre><code>(weave/run my-view\n  {:title \"My Application\"                             ; Page title\n   :head [:meta {:name \"description\" \n                 :content \"My app description\"}]       ; Additional HTML for head section\n   :view-port \"width=device-width, initial-scale=1\"})  ; Viewport meta tag\n</code></pre>"},{"location":"reference/90_running/#security-options","title":"Security Options","text":"<pre><code>(weave/run my-view\n  {:csrf-secret \"my-secret-key\"        ; Secret for CSRF token generation\n   :jwt-secret \"my-jwt-secret\"         ; Secret for JWT token generation/validation\n   :handler-options {:auth-required? true}}) ; Require authentication for all handlers by default\n</code></pre>"},{"location":"reference/90_running/#custom-routes-and-middleware","title":"Custom Routes and Middleware","text":"<pre><code>(require '[compojure.core :refer [GET POST]])\n\n(weave/run my-view\n  {:handlers [(GET \"/api/status\" [] {:status 200 :body \"OK\"})\n              (POST \"/api/data\" req (handle-data req))]\n   :middleware [my-logging-middleware\n                my-cors-middleware]})\n</code></pre>"},{"location":"reference/90_running/#progressive-web-app-pwa-configuration","title":"Progressive Web App (PWA) Configuration","text":"<pre><code>(weave/run my-view\n  {:icon \"icons/app-icon.png\"          ; Path to icon file in classpath (PNG format)\n   :pwa {:name \"My Application\"        ; Application name (defaults to :title)\n         :short-name \"MyApp\"           ; Application shortname (defaults to :name)\n         :description \"A great app\"    ; Application description\n         :display \"standalone\"         ; Display mode (default: \"standalone\")\n         :background-color \"#f2f2f2\"   ; Background color (default: \"#f2f2f2\")\n         :theme-color \"#ffffff\"        ; Theme color (default: \"#ffffff\")\n         :start-url \"/\"}})             ; Start URL when launched (default: \"/\")\n</code></pre>"},{"location":"reference/90_running/#complete-example","title":"Complete Example","text":"<pre><code>(ns my-app.core\n  (:require [weave.core :as weave]\n            [compojure.core :refer [GET]]\n            [integrant.core :as ig]))\n\n(defn my-view []\n  [:div\n   [:h1 \"My Weave Application\"]\n   [:button {:data-on-click (weave/handler []\n                              (weave/push-html! \"body\" [:p \"Button clicked!\"]))}\n    \"Click me\"]])\n\n(def app\n  (weave/run my-view\n    {:title \"My App\"\n     :http-kit {:port 3000}\n     :nrepl {:port 7888}\n     :sse {:enabled true\n           :keep-alive true}\n     :handlers [(GET \"/healthz\" [] {:status 200 :body \"healthy\"})]\n     :icon \"icons/app.png\"\n     :pwa {:name \"My Application\"\n           :description \"A sample Weave application\"}}))\n\n;; To stop the server:\n;; (ig/halt! app)\n</code></pre>"},{"location":"reference/90_running/#health-check-endpoint","title":"Health Check Endpoint","text":"<p>Weave automatically provides a health check endpoint at <code>/health</code> that returns:</p> <pre><code>{\"status\":\"ok\"}\n</code></pre> <p>This can be used for container orchestration health checks and load balancer monitoring.</p>"},{"location":"reference/91_testing/","title":"Testing Applications","text":"<p>Weave provides a dedicated browser testing component that simplifies end-to-end testing of Weave applications. The component integrates with Etaoin for browser automation and provides convenience functions for common testing operations.</p>"},{"location":"reference/91_testing/#setup","title":"Setup","text":""},{"location":"reference/91_testing/#adding-the-test-component","title":"Adding the Test Component","text":"<p>Add the browser testing component to your project's <code>deps.edn</code>:</p> <pre><code>{:aliases\n {:test {:extra-deps {weave/test {:git/url \"https://github.com/nakkaya/weave/\"\n                                  :deps/root \"components/test\"}\n                      }}}}\n</code></pre>"},{"location":"reference/91_testing/#prerequisites","title":"Prerequisites","text":"<p>Install ChromeDriver for browser automation:</p> <pre><code># On macOS with Homebrew\nbrew install chromedriver\n\n# On Ubuntu/Debian\nsudo apt-get install chromium-chromedriver\n\n# On other systems, download from:\n# https://chromedriver.chromium.org/\n</code></pre>"},{"location":"reference/91_testing/#basic-usage","title":"Basic Usage","text":""},{"location":"reference/91_testing/#import-the-testing-functions","title":"Import the Testing Functions","text":"<pre><code>(ns my-app.test\n  (:require [clojure.test :refer [deftest testing is]]\n            [weave.test.browser :refer [with-browser visible? click]]))\n</code></pre>"},{"location":"reference/91_testing/#writing-your-first-test","title":"Writing Your First Test","text":"<pre><code>(defn my-test-view []\n  [:div\n   [:h1 {:id \"title\"} \"Hello, Weave!\"]\n   [:button {:id \"click-me\"\n             :data-on-click (weave/handler []\n                              (weave/push-html!\n                                [:h1 {:id \"title\"} \"Clicked!\"]))}\n    \"Click Me\"]])\n\n(deftest basic-interaction-test\n  (with-browser my-test-view {:http-kit {:port 3333}}\n    (testing \"button click updates title\"\n      (visible? :title)\n      (is (= \"Hello, Weave!\" (el-text :title)))\n      (click :click-me)\n      (is (= \"Clicked!\" (el-text :title))))))\n</code></pre>"},{"location":"reference/91_testing/#testing-functions","title":"Testing Functions","text":""},{"location":"reference/91_testing/#core-functions","title":"Core Functions","text":""},{"location":"reference/91_testing/#with-browser","title":"<code>with-browser</code>","text":"<p>Macro that sets up a test server and browser driver for testing.</p> <pre><code>(with-browser view-fn server-options\n  ;; test body with access to *browser* binding\n  )\n</code></pre> <p>Parameters:</p> <ul> <li><code>view-fn</code> - Function that returns your Hiccup view</li> <li><code>server-options</code> - Map of Weave server options (same as <code>weave.core/run</code>)</li> </ul> <p>Features:</p> <ul> <li>Automatically starts Weave server</li> <li>Launches headless Chrome browser</li> <li>Navigates to test URL</li> <li>Provides <code>*browser*</code> binding for test functions</li> <li>Cleans up server and browser after test</li> </ul>"},{"location":"reference/91_testing/#visible","title":"<code>visible?</code>","text":"<p>Waits for an element to be visible and asserts its presence.</p> <pre><code>(visible? :my-element-id)\n</code></pre>"},{"location":"reference/91_testing/#click","title":"<code>click</code>","text":"<p>Clicks an element by ID.</p> <pre><code>(click :button-id)\n</code></pre>"},{"location":"reference/91_testing/#fill","title":"<code>fill</code>","text":"<p>Fills a form field with a value.</p> <pre><code>(fill :input-field \"some text\")\n</code></pre>"},{"location":"reference/91_testing/#el-text","title":"<code>el-text</code>","text":"<p>Gets the text content of an element.</p> <pre><code>(is (= \"Expected Text\" (el-text :element-id)))\n</code></pre>"},{"location":"reference/91_testing/#multi-tab-testing-functions","title":"Multi-Tab Testing Functions","text":""},{"location":"reference/91_testing/#new-tab","title":"<code>new-tab</code>","text":"<p>Opens a new browser tab with the same test URL.</p> <pre><code>(new-tab)\n</code></pre>"},{"location":"reference/91_testing/#tabs","title":"<code>tabs</code>","text":"<p>Returns all browser tab handles.</p> <pre><code>(let [tab-handles (tabs)]\n  ;; tab-handles is a vector of tab identifiers\n  )\n</code></pre>"},{"location":"reference/91_testing/#switch-tab","title":"<code>switch-tab</code>","text":"<p>Switches to a specific tab.</p> <pre><code>(let [[tab1 tab2] (tabs)]\n  (switch-tab tab2)  ; Switch to second tab\n  ;; perform actions in tab2\n  (switch-tab tab1)  ; Switch back to first tab\n  )\n</code></pre>"},{"location":"reference/91_testing/#examples","title":"Examples","text":""},{"location":"reference/91_testing/#testing-form-interactions","title":"Testing Form Interactions","text":"<pre><code>(defn contact-form-view []\n  [:form\n   [:input {:id \"name\" :type \"text\" :placeholder \"Name\"}]\n   [:input {:id \"email\" :type \"email\" :placeholder \"Email\"}]\n   [:button {:id \"submit\"\n             :data-on-click (weave/handler []\n                              (let [{:keys [name email]} (:params weave/*request*)]\n                                (weave/push-html! \"#result\"\n                                  [:div {:id \"result\"}\n                                   (str \"Hello \" name \" (\" email \")\")])))}\n    \"Submit\"]])\n\n(deftest form-submission-test\n  (with-browser contact-form-view {:http-kit {:port 3333}}\n    (testing \"form submission displays result\"\n      (visible? :name)\n      (fill :name \"John Doe\")\n      (fill :email \"john@example.com\")\n      (click :submit)\n      (visible? :result)\n      (is (= \"Hello John Doe (john@example.com)\" (el-text :result))))))\n</code></pre>"}]}