{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Weave is an easy-to-use, Clojure-based web application framework.</p> <p>Weave enables the creation of full-stack web applications in Clojure including the user interface. It's great for micro web apps, dashboards, admin interfaces, smart home solutions, and similar use cases.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Browser-based graphical user interface with real-time updates</li> <li>Reactive UI with server-sent events (SSE) for instant updates</li> <li>Standard GUI elements like labels, buttons, forms, and inputs</li> <li>Simple component organization with Hiccup syntax</li> <li>Client-side routing with hash-based navigation</li> <li>Built-in session management and authentication</li> <li>Server-side rendering with client-side interactivity</li> <li>Push updates to specific browser tabs or broadcast to all sessions</li> <li>GraalVM compatible. See <code>demo/Dockerfile</code> for static single   executable builds</li> <li>Automatically generate and serve the needed resources for   Progressive Web Apps (PWA)</li> </ul>"},{"location":"#why-weave","title":"Why Weave?","text":"<p>Weave combines the simplicity of Hiccup templates with the power of server-side rendering and real-time updates.  It provides a cohesive development experience where your UI logic lives alongside your application code.</p> <p>Unlike traditional SPAs that require separate frontend and backend codebases, Weave lets you build interactive web applications using only Clojure. The server pushes UI updates directly to the browser using server-sent events, eliminating the need for complex client-side JavaScript frameworks.</p>"},{"location":"create_a_project/","title":"Create a Project","text":"<p>Requirements:</p> <ul> <li>Java 11 or higher</li> <li>Clojure</li> </ul> <p>Weave is designed with simplicity in mind, you only need two files to get started.</p> <ul> <li><code>deps.edn</code></li> <li><code>src/app/core.clj</code></li> </ul> <p>Create a file called <code>deps.edn</code>,</p> <pre><code>{:paths   [\"src\"]\n\n :deps    {org.clojure/clojure {:mvn/version \"1.12.0\"}\n           weave/core {:git/url \"https://github.com/nakkaya/weave/\"\n                       :git/sha \"80dbc48c88510255b91a0948680bfa3c98200b2a\"}}\n\n :aliases {:dev {:exec-fn app.core/run}}}\n</code></pre> <p>Then in <code>src/app/core.clj</code></p> <pre><code>(ns app.core\n  (:require [weave.core :as weave]))\n\n(defn view []\n  [:div.p-6\n   [:h1#label.text-2xl.font-bold \"Hello Weave!\"]\n   [:button.bg-blue-500.text-white.px-4.py-2.rounded\n    {:data-on-click\n     (weave/handler []\n      (weave/push-html!\n       [:h1#label.text-2xl.font-bold \"Button was clicked!\"]))}\n    \"CLICK ME\"]])\n\n(defn run [_opts]\n  (weave/run #'view {}))\n</code></pre> <p>Run <code>clj -X:dev</code> to start the app on <code>http://localhost:8080</code></p>"},{"location":"create_a_project/#understanding-the-basics","title":"Understanding the Basics","text":""},{"location":"create_a_project/#markup","title":"Markup","text":"<p>Weave uses Chassis DSL for defining HTML elements in Clojure. </p> <ul> <li>Elements are represented as Clojure vectors: <code>[:div \"content\"]</code></li> <li>CSS classes are added with dot notation: <code>[:div.my-class \"content\"]</code></li> <li>IDs are added with hash notation: <code>[:h1#title \"Hello\"]</code></li> <li>Attributes are specified in a map: <code>[:button {:disabled true} \"Click\"]</code></li> <li>Tailwind CSS classes work seamlessly: <code>[:div.p-4.bg-blue-500 \"Styled content\"]</code></li> </ul>"},{"location":"create_a_project/#event-handlers","title":"Event Handlers","text":"<p>Weave uses Datastar on the client side for its reactive event handling system:</p> <ul> <li>Events are attached with data attributes: <code>:data-on-click /   :data-on-load /</code> etc.</li> <li>The <code>weave/handler</code> macro creates server-side event handlers</li> <li>Handlers can update the DOM, merge one or more fragments using   <code>push-html!</code> or <code>broadcast-html!</code>. By default,   Datastar merges fragments using Idiomorph,   which matches top level elements based on their ID</li> </ul>"},{"location":"create_a_project/#server-side-rendering","title":"Server-Side Rendering","text":"<ul> <li>The <code>view</code> function defines your initial UI state</li> <li>All rendering happens on the server</li> <li>Updates are pushed to the client via Server-Sent Events (SSE)</li> </ul>"},{"location":"reference/10_handlers/","title":"Handlers","text":"<p>Handlers are server-side functions that process client-side events. They are a core part of Weave's reactivity model.</p>"},{"location":"reference/10_handlers/#how-handlers-work","title":"How Handlers Work","text":"<ul> <li> <p>When you define a handler using the <code>weave/handler</code> macro, Weave:</p> <ul> <li>Generates a unique route path based on code structure and   captured variables. A hash is calculated for each handler,   handlers with the same hash share the same unique route</li> <li>Registers the handler function with that route</li> <li>Returns client-side Datastar   expression that will invoke this route when triggered</li> </ul> </li> <li> <p>When a client-side event occurs (like a button click):</p> <ul> <li>The browser sends a request to the unique route</li> <li>Weave executes your handler function on the server</li> <li>Your handler can update the DOM, execute scripts, etc.</li> </ul> </li> </ul>"},{"location":"reference/10_handlers/#handler-syntax","title":"Handler Syntax","text":"<pre><code>(weave/handler ^{options} [arguments]\n  ;; handler body\n  )\n</code></pre>"},{"location":"reference/10_handlers/#variable-capture","title":"Variable Capture","text":"<p>Any variables accessed within the handler body must be explicitly captured in the first argument vector. This is required for proper caching and ensures handlers work correctly with closures:</p> <pre><code>(let [user-name \"John\"\n      counter (atom 0)]\n  (weave/handler [user-name counter]\n    (weave/push-html! [:div \"Hello \" user-name \"! Count: \" @counter])))\n</code></pre>"},{"location":"reference/10_handlers/#handler-options","title":"Handler Options","text":"<p>Options are provided as metadata (optional):</p> <ul> <li><code>:auth-required?</code> - Whether authentication is required (defaults to   the value from <code>:handler-options</code> in the run configuration)</li> <li><code>:type</code> - Request content type (use <code>:form</code> for form submissions)</li> <li><code>:selector</code> - CSS selector for the form to submit (e.g. <code>\"#myform\"</code>)</li> <li><code>:request-cancellation</code> - Controls request cancellation behavior   (see Request Cancellation)</li> <li><code>:confirm</code> - String message for confirmation dialog. When present,   shows a browser <code>confirm()</code> dialog before executing the handler.   Example: <code>^{:confirm \"Are you sure you want to delete this item?\"} []</code></li> </ul>"},{"location":"reference/10_handlers/#request-cancellation","title":"Request Cancellation","text":"<p>Weave provides different modes for handling duplicate or rapid requests to the same handler route:</p>"},{"location":"reference/10_handlers/#auto-mode-default","title":"Auto Mode (Default)","text":"<pre><code>;; Default behavior - no need to specify\n(weave/handler []\n  (weave/push-html! [:div \"Processing...\"]))\n\n;; Explicitly specified\n(weave/handler ^{:request-cancellation \"auto\"} []\n  (weave/push-html! [:div \"Processing...\"]))\n</code></pre> <p>Behavior: When a user rapidly clicks the same button:</p> <ul> <li>The first request starts processing</li> <li>If a second click occurs before the first request completes, the   first request is cancelled</li> <li>The second request proceeds normally</li> <li>Only the latest request will complete</li> </ul> <p>Use case: Standard UI interactions where only the most recent user action matters.</p>"},{"location":"reference/10_handlers/#serialize-mode","title":"Serialize Mode","text":"<pre><code>(weave/handler ^{:request-cancellation \"serialize\"} []\n  ;; This operation will be serialized per route\n  (Thread/sleep 2000) ; Simulate slow operation\n  (weave/push-html! [:div \"Operation completed\"]))\n</code></pre> <p>Behavior: When a user rapidly clicks the same button:</p> <ul> <li>The first request starts processing and completes fully</li> <li>Additional clicks are silently ignored until the first request finishes</li> <li>Once the first request completes, new requests are allowed</li> <li>Ensures no duplicate operations occur</li> </ul> <p>Use case: Critical operations like database writes, payments, or any action that should not be duplicated.</p>"},{"location":"reference/10_handlers/#disabled-mode","title":"Disabled Mode","text":"<pre><code>(weave/handler ^{:request-cancellation \"disabled\"} []\n  (weave/push-html! [:div \"Processing...\"]))\n</code></pre> <p>Behavior: All requests are allowed to proceed concurrently.</p> <p>Use case: When you want to allow multiple simultaneous requests to the same handler.</p>"},{"location":"reference/10_handlers/#signal-naming-conventions","title":"Signal Naming Conventions","text":"<p>Weave automatically converts signal names between Clojure's kebab-case convention and JavaScript's camelCase convention:</p>"},{"location":"reference/10_handlers/#clojure-to-javascript-outgoing-signals","title":"Clojure to JavaScript (Outgoing Signals)","text":"<p>When you use <code>push-signal!</code> or similar functions, signal names are converted from kebab-case keywords to camelCase:</p> <pre><code>;; In your handler\n(weave/push-signal! {:user-name \"John\"\n                     :is-active true\n                     :item-count 42})\n\n;; JavaScript receives:\n;; {userName: \"John\", isActive: true, itemCount: 42}\n</code></pre>"},{"location":"reference/10_handlers/#javascript-to-clojure-incoming-signals","title":"JavaScript to Clojure (Incoming Signals)","text":"<p>When signals are sent from the browser (via Datastar), they are converted from camelCase to kebab-case keywords:</p> <pre><code>&lt;!-- In your HTML --&gt;\n&lt;div data-signals-userName=\"John\"\n     data-signals-isActive=\"true\"\n     data-signals-itemCount=\"42\"&gt;\n</code></pre> <pre><code>;; In your handler, signals are accessible as:\n(let [{:keys [user-name is-active item-count]} weave/*signals*]\n  ;; user-name = \"John\"\n  ;; is-active = true\n  ;; item-count = 42\n  )\n</code></pre>"},{"location":"reference/10_handlers/#accessing-url-query-parameters","title":"Accessing URL Query Parameters","text":"<p>Weave automatically parses URL query parameters and makes them available to handlers through the <code>weave/*query-params*</code> dynamic variable. Query parameters are extracted from the URL hash and parsed into a map with keyword keys.</p>"},{"location":"reference/10_handlers/#url-structure","title":"URL Structure","text":"<p>Query parameters can be included in the URL hash: <pre><code>https://your-app.com/#/dashboard?tab=settings&amp;view=compact&amp;debug\n</code></pre></p>"},{"location":"reference/10_handlers/#accessing-query-parameters-in-handlers","title":"Accessing Query Parameters in Handlers","text":"<pre><code>(defn dashboard-view []\n  [:div\n   [:button\n    {:data-on-click\n     (weave/handler []\n       (let [{:keys [tab view debug]} weave/*query-params*]\n         (weave/push-html!\n          [:div\n           [:p \"Current tab: \" (or tab \"default\")]\n           [:p \"View mode: \" (or view \"normal\")]\n           [:p \"Debug mode: \" (if debug \"enabled\" \"disabled\")]])))}\n    \"Show Query Params\"]])\n</code></pre>"},{"location":"reference/10_handlers/#examples","title":"Examples","text":""},{"location":"reference/10_handlers/#with-variables","title":"With Variables","text":"<pre><code>(let [message \"Hello from server!\"]\n  {:data-on-click\n   (weave/handler [message]\n    (weave/push-html! [:div#message message]))})\n</code></pre> <p>When this handler is registered, Weave:</p> <ul> <li>Creates a unique route based on the handler code and captured    variables.</li> <li>Sets up a POST endpoint for that route</li> <li>Returns client-side code that will POST to that route when the    click event occurs</li> </ul>"},{"location":"reference/10_handlers/#with-signals","title":"With Signals","text":"<p>Signals provide a powerful alternative to variable capture for managing dynamic state. Instead of capturing variables in closures, you can store state as signals in the browser and access them via <code>weave/*signals*</code>.</p> <pre><code>(defn click-count-view []\n  [::c/view#app\n   [::c/center-hv\n    [::c/card\n     [:div.text-center.text-6xl.font-bold.mb-6.text-blue-600\n      {:data-signals-count \"0\"\n       :data-text \"$count\"}]\n     [::c/button\n      {:size :xl\n       :variant :primary\n       :data-on-click (weave/handler []\n                        (let [count (or (:count weave/*signals*) 0)]\n                          (weave/push-signal! {:count (inc count)})))}\n      \"Increment Count\"]]]])\n</code></pre> <p>In this example:</p> <ul> <li><code>data-signals-click-count=\"0\"</code> initializes the signal with value 0</li> <li><code>data-text=\"$click\"</code> displays the signal value reactively</li> <li>The handler reads the current value from <code>weave/*signals*</code> and   updates it with <code>push-signal!</code></li> </ul>"},{"location":"reference/10_handlers/#with-data-call-with-","title":"With <code>:data-call-with-*</code>","text":"<p>The <code>:data-call-with-*</code> attribute is a Weave-specific feature that provides way to pass arguments to handlers while avoiding variable capture.</p> <pre><code>(defn action-buttons-view []\n  [:div#app\n   [:div#result \"No action performed yet\"]\n   ;; Define a single shared handler\n   (let [handle-action (weave/handler []\n                         (let [{:keys [action item-id]} weave/*signals*]\n                           (weave/push-html!\n                             [:div#result (str \"Action: \" action \", Item: \" item-id)])))]\n     [:div.button-group\n      [::c/button\n       {:data-call-with-action \"edit\"\n        :data-call-with-item-id \"123\"\n        :data-on-click handle-action}\n       \"Edit\"]\n      [::c/button\n       {:data-call-with-action \"delete\"\n        :data-call-with-item-id \"123\"\n        :data-on-click handle-action}\n       \"Delete\"]])])\n</code></pre>"},{"location":"reference/10_handlers/#scoping-rules","title":"Scoping Rules","text":"<pre><code>;; Example showing inheritance\n[:div {:data-call-with-action \"noop\"}  ; Parent element\n [:button {:data-call-with-action \"edit\"  ; Child element\n           :data-call-with-id \"123\"\n           :data-on-click handler}\n  \"Edit User\"]]\n;; Result: signals will be {:action \"edit\", :id \"123\"}\n</code></pre>"},{"location":"reference/10_handlers/#with-confirmation-dialog","title":"With Confirmation Dialog","text":"<pre><code>;; Simple delete confirmation\n{:data-on-click\n (weave/handler ^{:confirm \"Are you sure you want to delete this item?\"} []\n   (delete-item!)\n   (weave/push-html! [:div \"Item deleted\"]))}\n</code></pre> <p>The <code>:confirm</code> option generates JavaScript that shows a browser confirmation dialog before executing the handler. If the user clicks \"Cancel\", the handler will not execute.</p>"},{"location":"reference/10_handlers/#problem-route-explosion-with-closures","title":"Problem: Route Explosion with Closures","text":"<p>When using variable capture, each unique combination of captured variables creates a separate route. This becomes problematic with things like table rows where each action becomes a new route and nothing shared:</p> <pre><code>;; BAD: Creates separate handler for each row \u00d7 action combination\n(defn user-table-bad [users]\n  [:table\n   (for [user users]\n     [:tr\n      [:td (:name user)]\n      [:td\n       [::c/button\n        {:data-on-click (weave/handler [user] ; Captures user - creates unique route!\n                          (delete-user! (:id user))\n                          (weave/push-html! (user-table-bad (get-updated-users))))}\n        \"Delete\"]\n       [::c/button\n        {:data-on-click (weave/handler [user] ; Another unique route per user!\n                          (promote-user! (:id user))\n                          (weave/push-html! (user-table-bad (get-updated-users))))}\n        \"Promote\"]]])])\n\n;; With 100 users \u00d7 2 actions = 200 different routes registered!\n</code></pre>"},{"location":"reference/10_handlers/#solution-shared-handlers-with-data-call-with-","title":"Solution: Shared Handlers with <code>:data-call-with-*</code>","text":"<pre><code>;; GOOD: Only 1 handler total, regardless of number of users\n(defn user-table [users]\n  (let [handle-action (weave/handler []\n                        (let [{:keys [user-id action]} weave/*signals*]\n                          (case action\n                            \"delete\" (delete-user! user-id)\n                            \"promote\" (promote-user! user-id))\n                          (weave/push-html! (user-table (get-updated-users)))))]\n    [:table\n     (for [user users]\n       [:tr\n        [:td (:name user)]\n        [:td\n         [::c/button\n          {:data-call-with-user-id (:id user)\n           :data-call-with-action \"delete\"\n           :data-on-click handle-action}\n          \"Delete\"]\n         [::c/button\n          {:data-call-with-user-id (:id user)\n           :data-call-with-action \"promote\"\n           :data-on-click handle-action}\n          \"Promote\"]]])]))\n\n;; Only 1 handler registered total - shared across all rows and actions!\n</code></pre>"},{"location":"reference/10_handlers/#request-cancellation-with-data-call-with-","title":"Request Cancellation with <code>:data-call-with-*</code>","text":"<p>When using <code>:data-call-with-*</code> attributes, the request cancellation behavior is controlled by the handler's metadata:</p> <pre><code>(defn payment-view []\n  (let [payment-handler (weave/handler ^{:request-cancellation \"serialize\"} []\n                          (let [{:keys [action amount]} weave/*signals*]\n                            (process-payment! amount)\n                            (weave/push-html! [:div \"Payment processed\"])))]\n    [:button\n     {:data-call-with-action \"process-payment\"\n      :data-call-with-amount \"100\"\n      :data-on-click payment-handler}\n     \"Process Payment\"]))\n</code></pre> <p>The serialize behavior ensures that even with rapid clicking, only one payment operation will execute.</p>"},{"location":"reference/20_push_broadcast/","title":"Push and Broadcast","text":"<p>Weave provides several functions for updating the UI and communicating with the client browser. These functions fall into two main categories:</p> <ul> <li>Push functions: Send updates to the specific browser tab/window   that triggered the current handler</li> <li>Broadcast functions: Send updates to all browser tabs/windows   that share the same session ID</li> </ul>"},{"location":"reference/20_push_broadcast/#html-updates","title":"HTML Updates","text":""},{"location":"reference/20_push_broadcast/#push-html","title":"push-html!","text":"<p>Pushes HTML updates to the specific browser tab/window that triggered the handler.</p> <pre><code>(weave/push-html! [:div#message \"Operation completed successfully!\"])\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcast-html","title":"broadcast-html!","text":"<p>Pushes HTML updates to all browser tabs/windows that share the same session ID.</p> <pre><code>(weave/broadcast-html! [:div#notification \"New message received!\"])\n</code></pre>"},{"location":"reference/20_push_broadcast/#navigation","title":"Navigation","text":""},{"location":"reference/20_push_broadcast/#push-path","title":"push-path!","text":"<p>Changes the URL hash for the specific browser tab/window that triggered the handler. Optionally renders a new view.</p> <pre><code>;; Simple navigation\n(weave/push-path! \"/dashboard\")\n\n;; Navigation with view update\n(weave/push-path! \"/profile\" \n  (fn [] \n    [:div#profile \n     [:h1 \"User Profile\"]\n     [:p \"Profile content here\"]]))\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcast-path","title":"broadcast-path!","text":"<p>Changes the URL hash for all browser tabs/windows that share the same session ID. Optionally renders a new view.</p> <pre><code>;; Simple navigation for all tabs\n(weave/broadcast-path! \"/logout\")\n\n;; Navigation with view update for all tabs\n(weave/broadcast-path! \"/maintenance\" \n  (fn [] \n    [:div.alert \n     [:h1 \"Maintenance Mode\"]\n     [:p \"The system is currently undergoing maintenance.\"]]))\n</code></pre>"},{"location":"reference/20_push_broadcast/#javascript-execution","title":"JavaScript Execution","text":""},{"location":"reference/20_push_broadcast/#push-script","title":"push-script!","text":"<p>Sends JavaScript to the specific browser tab/window for execution.</p> <pre><code>(weave/push-script! \"console.log('Handler executed');\")\n</code></pre>"},{"location":"reference/20_push_broadcast/#push-reload","title":"push-reload!","text":"<p>Sends a reload command to the specific browser tab/window.</p> <pre><code>(weave/push-reload!)\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcast-script","title":"broadcast-script!","text":"<p>Sends JavaScript to all browser tabs/windows for execution.</p> <pre><code>(weave/broadcast-script! \"localStorage.clear();\")\n</code></pre>"},{"location":"reference/20_push_broadcast/#data-and-state","title":"Data and State","text":""},{"location":"reference/20_push_broadcast/#push-signal","title":"push-signal!","text":"<p>Sends updated signal values to the specific browser tab/window.</p> <pre><code>(weave/push-signal! {:user {:name \"John\" :role \"admin\"}})\n</code></pre> <p>Signals are client-side state values that can be accessed in the browser using Datastar.  They can be used for reactive UI updates, storing user preferences, or maintaining application state. Signals are stored in the browser and can be accessed in HTML attributes using the <code>data-signals-</code> prefix:</p> <pre><code>[:div {:data-signals-username \"''\"}\n \"Welcome, \"\n [:span {:data-text \"$username\"}]]\n\n;; Later update the signal\n(weave/push-signal! {:username \"John\"})\n</code></pre>"},{"location":"reference/20_push_broadcast/#common-patterns","title":"Common Patterns","text":""},{"location":"reference/20_push_broadcast/#form-submission-handler","title":"Form Submission Handler","text":"<pre><code>[:form\n {:data-on-submit\n  (weave/handler ^{:type :form} []\n   (let [form-data (:params weave/*request*)]\n     (save-data! form-data)\n     (weave/push-html! \n      [:div#status.text-green-500 \"Data saved successfully!\"])))}\n [:input {:type \"text\" :name \"username\"}]\n [:button {:type \"submit\"} \"Save\"]]\n</code></pre>"},{"location":"reference/20_push_broadcast/#toggling-ui-elements","title":"Toggling UI Elements","text":"<pre><code>(let [panel-visible (atom false)]\n  [:button\n   {:data-on-click\n    (weave/handler [panel-visible]\n     (weave/push-html!\n      [:div#panel\n       {:class (if @panel-visible \"hidden\" \"block\")}\n       \"Panel content\"])\n     (swap! panel-visible not))}\n   \"Toggle Panel\"])\n</code></pre>"},{"location":"reference/20_push_broadcast/#broadcasting-notifications","title":"Broadcasting Notifications","text":"<pre><code>(defn notify-all-users [message]\n  (weave/broadcast-html!\n   [:div#notification.fixed.top-0.right-0.m-4.p-4.bg-blue-500.text-white.rounded\n    {:data-on-load\n     (weave/handler []\n      (weave/push-script!\n       \"setTimeout(() =&gt; document.getElementById('notification').remove(), 5000)\"))}\n    message]))\n</code></pre>"},{"location":"reference/30_session/","title":"Session Management","text":"<p>Weave provides a session management system that handles authentication, CSRF protection, and server-sent event (SSE) connections.</p>"},{"location":"reference/30_session/#how-sessions-work-in-weave","title":"How Sessions Work in Weave","text":"<p>Weave's session system uses three cookies to manage user state:</p> <ol> <li>weave-sid: The session ID cookie that uniquely identifies a browser session</li> <li>weave-csrf: A CSRF token that protects against cross-site request forgery attacks</li> <li>weave-auth: A JWT (JSON Web Token) that stores authenticated user information</li> </ol>"},{"location":"reference/30_session/#session-flow","title":"Session Flow","text":"<ol> <li> <p>When a user first visits a Weave application:</p> <ul> <li>A unique session ID is generated</li> <li>A CSRF token is derived from this session ID</li> <li>Both are set as cookies in the browser</li> </ul> </li> <li> <p>For authenticated sessions:</p> <ul> <li>When a user signs in, their identity information is stored in a JWT</li> <li>The JWT is set as the <code>weave-auth</code> cookie</li> <li>Subsequent requests include this cookie, allowing the server to   verify the user's identity</li> </ul> </li> <li> <p>For all requests:</p> <ul> <li>The CSRF token must be included in the <code>x-csrf-token</code> header</li> <li>The server verifies that the CSRF token matches the expected   value for the session ID</li> <li>If valid, the request proceeds; otherwise, it's rejected with a   403 status</li> </ul> </li> </ol>"},{"location":"reference/30_session/#managing-connections","title":"Managing Connections","text":"<p>Weave tracks active browser connections using a combination of session ID and instance ID:</p> <ul> <li>Each browser tab/window gets a unique instance ID</li> <li>Multiple tabs can share the same session ID</li> <li>This allows Weave to:</li> <li>Push updates to specific tabs (<code>push-html!</code>)</li> <li>Broadcast to all tabs for a user (<code>broadcast-html!</code>)</li> </ul>"},{"location":"reference/30_session/#session-management-functions","title":"Session Management Functions","text":""},{"location":"reference/30_session/#authentication","title":"Authentication","text":"<pre><code>;; Sign in a user and get the auth cookie string\n(weave/set-cookie! (session/sign-in {:name \"username\" :role \"admin\"}))\n\n;; Sign out a user by clearing the auth cookie\n(weave/set-cookie! (session/sign-out))\n</code></pre>"},{"location":"reference/30_session/#using-set-cookie","title":"Using <code>set-cookie!</code>","text":"<p>The <code>set-cookie!</code> function is a key part of session management in Weave. The function works by sending JavaScript that sets the document.cookie value, which updates or creates the specified cookie in the browser.</p> <pre><code>;; Basic usage\n(weave/set-cookie! \"mycookie=value; Path=/; Max-Age=86400\")\n\n;; Sign in example\n(weave/handler []\n  (weave/set-cookie! \n    (session/sign-in {:name \"Weave\" :role \"User\"}))\n  (weave/push-reload!))\n\n;; Sign out example\n(weave/handler []\n  (weave/set-cookie! (session/sign-out))\n  (weave/push-path! \"/sign-in\"))\n</code></pre>"},{"location":"reference/30_session/#session-activity-tracking","title":"Session Activity Tracking","text":"<p>Weave automatically tracks the last activity timestamp for each session instance whenever a handler is called. This enables you to:</p> <ol> <li>Monitor when users were last active</li> <li>Automatically logout stale sessions</li> <li>Build features like \"active users\" displays</li> </ol>"},{"location":"reference/30_session/#activity-tracking-functions","title":"Activity Tracking Functions","text":"<pre><code>(require '[weave.session :as session])\n\n;; Get the last activity timestamp for a specific session instance\n(session/last-activity session-id instance-id)\n;; =&gt; 1672531200000 (timestamp in milliseconds)\n\n;; Get all activity data for a session\n;; Returns a map of {instance-id -&gt; timestamp}\n(session/session-activity session-id)\n;; =&gt; {\"instance-123\" 1672531200000, \"instance-456\" 1672531150000}\n\n;; Get all session activity data\n;; Returns a map of {session-id -&gt; {instance-id -&gt; timestamp}}\n(session/session-activities)\n;; =&gt; {\"session-abc\" {\"instance-123\" 1672531200000}\n;;     \"session-def\" {\"instance-456\" 1672531150000}}\n\n;; Get activity data for a specific session\n;; Returns a map of {instance-id -&gt; timestamp}\n(session/session-activities \"session-abc\")\n;; =&gt; {\"instance-123\" 1672531200000}\n</code></pre>"},{"location":"reference/30_session/#configuration","title":"Configuration","text":"<p>When starting a Weave application, you can configure session security:</p> <pre><code>(weave/run view-fn \n  {:csrf-secret \"your-csrf-secret\"  ;; Secret for CSRF token generation\n   :jwt-secret \"your-jwt-secret\"})  ;; Secret for JWT signing\n</code></pre> <p>If not provided, Weave will generate random secrets for each server instance.</p>"},{"location":"reference/40_javascript/","title":"JavaScript","text":"<p>Weave provides JavaScript interoperability through Squint, a lightweight Clojure-to-JavaScript transpiler. This allows you to write Clojure code that gets converted to JavaScript for client-side execution.</p>"},{"location":"reference/40_javascript/#how-javascript-support-works","title":"How JavaScript Support Works","text":"<p>Weave uses Squint to:</p> <ol> <li>Transpile Clojure code to JavaScript at runtime</li> <li>Execute the generated JavaScript in the browser</li> <li>Integrate with the DOM and browser APIs</li> </ol> <p>This approach gives you the expressiveness of Clojure with direct access to browser capabilities.</p>"},{"location":"reference/40_javascript/#using-javascript-in-weave","title":"Using JavaScript in Weave","text":"<p>There are several ways to use JavaScript in Weave:</p>"},{"location":"reference/40_javascript/#1-inline-scripts-with-push-script","title":"1. Inline Scripts with <code>push-script!</code>","text":"<p>The simplest way to execute JavaScript is with <code>push-script!</code>:</p> <pre><code>(weave/push-script!\n  (squint/clj-&gt;js\n    (js/alert \"Hello from Clojure!\")))\n</code></pre> <p>This transpiles the Clojure code to JavaScript and sends it to the current browser tab for execution.</p>"},{"location":"reference/40_javascript/#2-broadcasting-scripts-to-all-sessions","title":"2. Broadcasting Scripts to All Sessions","text":"<p>To send JavaScript to all connected browser tabs for the current user:</p> <pre><code>(weave/broadcast-script!\n  (squint/clj-&gt;js\n    (js/console.log \"This appears in all tabs\")))\n</code></pre>"},{"location":"reference/40_javascript/#3-event-handlers-with-javascript","title":"3. Event Handlers with JavaScript","text":"<p>You can combine DOM updates with JavaScript execution:</p> <pre><code>{:data-on-click\n (weave/handler []\n  ;; Update the DOM\n  (weave/push-html! [:div#status \"Processing...\"])\n\n  ;; Execute JavaScript\n  (weave/push-script!\n   (squint/clj-&gt;js\n    (let [result (js/fetch \"/api/data\")]\n      (.then result #(.json %))\n      (.then result #(js/console.log \"Data received:\" %))\n      (.catch result #(js/console.error \"Error:\" %))))))}\n</code></pre>"},{"location":"reference/40_javascript/#4-dom-manipulation","title":"4. DOM Manipulation","text":"<p>You can directly manipulate the DOM:</p> <pre><code>(weave/push-script!\n (squint/clj-&gt;js\n  (let [element (js/document.getElementById \"counter\")]\n    (set! (.-textContent element) \n          (inc (js/parseInt (.-textContent element)))))))\n</code></pre>"},{"location":"reference/40_javascript/#the-clj-js-macro","title":"The <code>clj-&gt;js</code> Macro","text":"<p>The <code>clj-&gt;js</code> macro is the primary tool for JavaScript interoperability:</p> <pre><code>(weave/push-script!\n (squint/clj-&gt;js\n  (defn greet [name]\n    (js/alert (str \"Hello, \" name \"!\")))\n\n  (greet \"World\")))\n</code></pre> <p>This transpiles the Clojure code to JavaScript and executes it in the browser.</p> <p>The <code>clj-&gt;js</code> macro accepts an optional map of options:</p> <pre><code>(weave/push-script!\n (clj-&gt;js\n  {:elide-imports true\n   :elide-exports true\n   :top-level false\n   :context :expr\n   :core-alias \"squint.core\"}\n\n  (defn advanced-example []\n    (js/console.log \"Custom options\"))\n\n  (advanced-example)))\n</code></pre>"},{"location":"reference/40_javascript/#limitations-and-differences-from-clojurescript","title":"Limitations and Differences from ClojureScript","text":"<p>While Squint provides excellent JavaScript interoperability, it's important to understand its limitations:</p> <ol> <li>Not Full ClojureScript: Squint is a lightweight transpiler, not a complete ClojureScript implementation</li> <li>Different Data Structures: Squint maps to JavaScript primitives</li> <li>Limited Standard Library: Only a subset of Clojure's core functions are available</li> <li>No Advanced Optimizations: Unlike ClojureScript, there's no advanced compilation or optimization</li> <li>Runtime Transpilation: Code is transpiled at runtime, not ahead-of-time</li> </ol>"},{"location":"reference/40_javascript/#example-timer-application","title":"Example: Timer Application","text":"<p>Here's a complete example of a timer application using JavaScript interoperability:</p> <pre><code>(defn timer-view []\n  [:div.p-6\n   [:h1#timer.text-4xl.font-bold \"0\"]\n   [:div.flex.gap-2.mt-4\n    [:button.bg-green-500.text-white.px-4.py-2.rounded\n     {:data-on-click\n      (weave/handler []\n       (weave/push-script!\n        (squint/clj-&gt;js\n         (let [interval-id (js/setInterval\n                            (fn []\n                              (let [timer (js/document.getElementById \"timer\")\n                                    current (js/parseInt (.-textContent timer))]\n                                (set! (.-textContent timer) (inc current))))\n                            1000)]\n           (set! (.. js/window -weaveTimerId) interval-id)))))}\n     \"Start\"]\n\n    [:button.bg-red-500.text-white.px-4.py-2.rounded\n     {:data-on-click\n      (weave/handler []\n       (weave/push-script!\n        (squint/clj-&gt;js\n         (when (.. js/window -weaveTimerId)\n           (js/clearInterval (.. js/window -weaveTimerId))\n           (set! (.. js/window -weaveTimerId) nil)))))}\n     \"Stop\"]\n\n    [:button.bg-blue-500.text-white.px-4.py-2.rounded\n     {:data-on-click\n      (weave/handler []\n       (weave/push-script!\n        (squint/clj-&gt;js\n         (let [timer (js/document.getElementById \"timer\")]\n           (set! (.-textContent timer) \"0\")))))}\n     \"Reset\"]]])\n</code></pre> <p>This example demonstrates:</p> <ul> <li>Setting up a JavaScript interval timer</li> <li>Storing state in a browser window property</li> <li>Manipulating the DOM directly</li> <li>Cleaning up resources when stopping the timer</li> </ul>"},{"location":"reference/45_custom_routes/","title":"Custom Routes","text":"<p>Weave allows you to define custom routes to handle requests outside of the standard Weave event system. This is useful for creating API endpoints, handling file uploads, or integrating with external services.</p>"},{"location":"reference/45_custom_routes/#adding-custom-routes","title":"Adding Custom Routes","text":"<p>Custom routes are added through the <code>:handlers</code> option when starting your Weave application. These routes use Compojure syntax and are merged with Weave's internal routes.</p> <pre><code>(weave/run view-fn\n  {:handlers [(GET \"/api/data\" [] (api-handler))\n              (POST \"/api/upload\" [] (upload-handler))\n              (GET \"/api/download/:id\" [id] (download-handler id))]})\n</code></pre>"},{"location":"reference/45_custom_routes/#route-handlers","title":"Route Handlers","text":"<p>Route handlers are regular Ring handler functions that take a request map and return a response map:</p> <pre><code>(defn api-handler [req]\n  {:status 200\n   :headers {\"Content-Type\" \"application/json\"}\n   :body \"{\\\"message\\\":\\\"Hello from API\\\"}\"})\n</code></pre>"},{"location":"reference/45_custom_routes/#authentication-for-custom-routes","title":"Authentication for Custom Routes","text":"<p>Custom routes don't automatically use Weave's authentication system. To protect your routes, you need to manually check the request for authentication information,</p> <pre><code>(defn authenticated-api [req]\n  (if (:identity req)\n    {:status 200\n     :headers {\"Content-Type\" \"application/json\"}\n     :body \"{\\\"data\\\":\\\"Protected data\\\"}\"}\n    {:status 403\n     :headers {\"Content-Type\" \"application/json\"}\n     :body \"{\\\"error\\\":\\\"Unauthorized\\\"}\"}))\n</code></pre>"},{"location":"reference/45_custom_routes/#accessing-weave-context","title":"Accessing Weave Context","text":"<p>Custom routes have access to the same request context as Weave handlers, including session information:</p> <pre><code>(defn session-info [req]\n  (let [session-id (session/get-sid req)]\n    {:status 200\n     :headers {\"Content-Type\" \"application/json\"}\n     :body (str \"{\\\"session\\\":\\\"\" session-id \"\\\"}\")}))\n</code></pre>"},{"location":"reference/50_pwa/","title":"Progressive Web Apps (PWA)","text":"<p>Weave includes built-in support for Progressive Web Apps (PWAs), allowing your applications to be installed on devices and provide a more app-like experience.</p>"},{"location":"reference/50_pwa/#pwa-support-in-weave","title":"PWA Support in Weave","text":"<p>Weave automatically generates and serves the necessary resources for PWAs:</p> <ol> <li>Web App Manifest: A JSON file that tells the browser about your    application</li> <li>Icons: Various sized icons for different devices and contexts</li> </ol> <p>Note: Currently, Weave does not automatically generate a service worker, which is required for full PWA functionality like offline support. If you need offline capabilities, you'll need to implement a custom service worker and register it in your application.</p>"},{"location":"reference/50_pwa/#configuration","title":"Configuration","text":"<p>To enable PWA features in your Weave application, provide an <code>:icon</code> path and optional <code>:pwa</code> configuration when starting your application:</p> <pre><code>(weave/run view-fn \n  {:title \"My PWA App\"\n   :icon \"public/my-icon.png\"  ;; Path to an icon in your classpath\n   :pwa {:name \"My PWA App\"\n         :short-name \"MyApp\"\n         :description \"A description of my application\"\n         :display \"standalone\"\n         :background-color \"#f2f2f2\"\n         :theme-color \"#4a86e8\"\n         :start-url \"/\"}})\n</code></pre>"},{"location":"reference/50_pwa/#icon-requirements","title":"Icon Requirements","text":"<p>The icon you provide should be:</p> <ul> <li>A PNG image</li> <li>High resolution (at least 512x512 pixels recommended)</li> <li>Located in your classpath (typically in resources directory)</li> </ul> <p>Weave will automatically resize your icon to create:</p> <ul> <li><code>/favicon.png</code> (32x32) - For browser tabs</li> <li><code>/icon-180.png</code> (180x180) - For iOS home screens</li> <li><code>/icon-192.png</code> (192x192) - For Android home screens</li> <li><code>/icon-512.png</code> (512x512) - For high-resolution displays</li> </ul>"},{"location":"reference/50_pwa/#web-app-manifest-options","title":"Web App Manifest Options","text":"<p>The <code>:pwa</code> configuration map supports these options:</p> Option Description Default <code>:name</code> Full application name Value of <code>:title</code> option <code>:short-name</code> Short name for app icons Same as <code>:name</code> <code>:description</code> App description None <code>:display</code> Display mode <code>\"standalone\"</code> <code>:background-color</code> Background color during loading <code>\"#f2f2f2\"</code> <code>:theme-color</code> Theme color for browser UI <code>\"#ffffff\"</code> <code>:start-url</code> URL to load when app launches <code>\"/\"</code>"},{"location":"reference/50_pwa/#testing-your-pwa","title":"Testing Your PWA","text":"<p>Modern browsers provide tools to test PWA functionality:</p> <ol> <li>In Chrome, open DevTools and go to the \"Application\" tab</li> <li>Check the \"Manifest\" section to verify your web app manifest</li> <li>Use Lighthouse (in the \"Audits\" tab) to test PWA compliance</li> </ol>"},{"location":"reference/50_pwa/#installation-experience","title":"Installation Experience","text":"<p>When users visit your Weave application in a supported browser:</p> <ol> <li>After some engagement, the browser may show an \"Add to Home Screen\" prompt</li> <li>Users can also manually install the app through the browser menu</li> <li>Once installed, the app will appear on the device's home screen or app launcher</li> <li>When launched, it will open in a standalone window without browser UI</li> </ol>"},{"location":"reference/60_components/","title":"Components","text":"<p>Weave provides a collection of pre-styled UI components through the <code>weave.components</code> namespace. These components help you build consistent, attractive interfaces without writing extensive CSS or HTML markup.</p>"},{"location":"reference/60_components/#overview","title":"Overview","text":"<p>The components namespace offers themed, pre-styled UI elements that follow modern design principles. These components are built on top of Tailwind CSS and are designed to work seamlessly with Weave's server-side rendering approach.</p>"},{"location":"reference/60_components/#usage","title":"Usage","text":"<p>To use Weave components, require the namespace in your application:</p> <pre><code>(ns your-app.core\n  (:require [weave.components :as c]))\n</code></pre> <p>Then use the components in your views with the namespace keyword syntax:</p> <pre><code>(defn my-view []\n  [::c/view#app\n   [::c/card\n    [:h1.text-2xl \"Hello World\"]\n    [::c/button {:variant :primary} \"Click Me\"]]])\n</code></pre>"},{"location":"reference/60_components/#component-customization","title":"Component Customization","text":"<p>Most components accept options as a map of attributes:</p> <pre><code>[::c/button \n {:variant :primary    ; Visual style\n  :size :lg            ; Size variant\n  :disabled true       ; State\n  :class \"mt-4\"}       ; Additional classes\n \"Submit\"]\n</code></pre>"},{"location":"reference/60_components/#work-in-progress","title":"Work in Progress","text":"<p>The components namespace is a work in progress. New components are being added regularly, and existing components may evolve based on user feedback and best practices.</p> <p>Future plans include: - More specialized components for data visualization - Enhanced theming capabilities - Responsive design improvements - Accessibility enhancements</p> <p>For the most up-to-date information on available components, refer to the source code or examples in the demo application.</p>"},{"location":"reference/70_resources/","title":"Bundling Resources","text":"<p>Weave comes bundled with several frontend resources to make building web applications easier. These resources are served from the classpath and are available to your application without any additional configuration.</p>"},{"location":"reference/70_resources/#bundled-resources","title":"Bundled Resources","text":""},{"location":"reference/70_resources/#tailwind-css","title":"Tailwind CSS","text":"<p>Tailwind CSS v3.4.16 is included, it provides a utility-first CSS framework. You can use Tailwind classes directly in your Hiccup markup:</p> <pre><code>[:div.flex.items-center.justify-between.p-4.bg-white.shadow\n [:h1.text-xl.font-bold \"My Application\"]\n [:button.px-4.py-2.bg-blue-500.text-white.rounded.hover:bg-blue-600\n  \"Click Me\"]]\n</code></pre>"},{"location":"reference/70_resources/#datastar","title":"Datastar","text":"<p>Datastar v1.0.0-beta.11 is included for client-side reactivity and event handling. Weave uses Datastar internally for its event system and server-sent events (SSE) communication.</p>"},{"location":"reference/70_resources/#squint","title":"Squint","text":"<p>Squint v0.8.147 is included for JavaScript interoperability, allowing you to write Clojure code that gets transpiled to JavaScript for client-side execution.</p>"},{"location":"reference/70_resources/#heroicons","title":"Heroicons","text":"<p>Weave includes Heroicons as an SVG sprite, making it easy to use these popular icons in your application. The icons are accessible through the <code>::icon</code> component in the <code>weave.components</code> namespace:</p> <pre><code>(ns your-app.core\n  (:require [weave.components :as c]))\n\n(defn view []\n  [:div\n   [::c/icon#solid-home {:class \"h-6 w-6 text-blue-500\"}]\n   [::c/icon#solid-user {:class \"h-6 w-6 text-green-500\"}]\n   [::c/icon#solid-cog {:class \"h-6 w-6 text-gray-500\"}]])\n</code></pre> <p>The icon ID format is <code>#[style]-[name]</code> where:</p> <ul> <li><code>style</code> is either <code>solid</code> or <code>outline</code></li> <li><code>name</code> is the icon name from Heroicons (e.g., <code>home</code>, <code>user</code>, <code>cog</code>)</li> </ul> <p>You can customize the size and color of icons using Tailwind classes.</p>"},{"location":"reference/70_resources/#serving-custom-resources","title":"Serving Custom Resources","text":"<p>You can serve your own static resources by placing them in the <code>resources/public</code> directory of your project. Files in this directory will be automatically served at the root path of your application.</p> <p>For example:</p> <pre><code>your-project/\n\u251c\u2500\u2500 resources/\n\u2502   \u2514\u2500\u2500 public/\n\u2502       \u251c\u2500\u2500 css/\n\u2502       \u2502   \u2514\u2500\u2500 custom.css\n\u2502       \u251c\u2500\u2500 js/\n\u2502       \u2502   \u2514\u2500\u2500 app.js\n\u2502       \u2514\u2500\u2500 images/\n\u2502           \u2514\u2500\u2500 logo.png\n</code></pre> <p>These files would be accessible at:</p> <ul> <li><code>http://localhost:8080/css/custom.css</code></li> <li><code>http://localhost:8080/js/app.js</code></li> <li><code>http://localhost:8080/images/logo.png</code></li> </ul>"},{"location":"reference/70_resources/#using-custom-resources","title":"Using Custom Resources","text":"<p>To use your custom resources in your application:</p> <pre><code>(weave/run view-fn\n  {:head\n   [[:link {:rel \"stylesheet\" :href \"/css/custom.css\"}]\n    [:script {:src \"/js/app.js\"}]]})\n</code></pre> <pre><code>(defn view []\n  [:div\n   [:img {:src \"/images/logo.png\" :alt \"Logo\"}]])\n</code></pre>"},{"location":"reference/90_running/","title":"Running Applications","text":"<p>The <code>weave.core/run</code> function is the main entry point for starting a Weave application. It creates and starts an integrated web server with all the necessary components for your application.</p>"},{"location":"reference/90_running/#basic-usage","title":"Basic Usage","text":"<pre><code>(ns my-app.core\n  (:require [weave.core :as weave]))\n\n(defn my-view []\n  [:div\n   [:h1 \"Hello, Weave!\"]\n   [:p \"Welcome to my application\"]])\n\n(defn -main []\n  (weave/run my-view {}))\n</code></pre>"},{"location":"reference/90_running/#function-signature","title":"Function Signature","text":"<pre><code>(run view options)\n</code></pre> <p>Parameters:</p> <ul> <li><code>view</code> - A function that returns the Hiccup view to render</li> <li><code>options</code> - A map of server configuration options</li> </ul> <p>Returns:</p> <ul> <li>An integrant system that can be halted with <code>(integrant.core/halt! system)</code></li> </ul>"},{"location":"reference/90_running/#configuration-options","title":"Configuration Options","text":""},{"location":"reference/90_running/#http-server-options-http-kit","title":"HTTP Server Options (<code>:http-kit</code>)","text":"<pre><code>(weave/run my-view\n  {:http-kit {:bind \"127.0.0.1\"  ; IP address to bind to (default: \"0.0.0.0\")\n              :port 3000}})      ; HTTP server port (default: 8080)\n</code></pre>"},{"location":"reference/90_running/#nrepl-server-options-nrepl","title":"nREPL Server Options (<code>:nrepl</code>)","text":"<pre><code>(weave/run my-view\n  {:nrepl {:bind \"127.0.0.1\"     ; IP address to bind to (default: \"0.0.0.0\")\n           :port 7888}})         ; nREPL server port (default: 8888)\n</code></pre>"},{"location":"reference/90_running/#server-sent-events-options-sse","title":"Server-Sent Events Options (<code>:sse</code>)","text":"<pre><code>(weave/run my-view\n  {:sse {:enabled true          ; Whether to enable SSE (default: true)\n         :keep-alive false}})   ; Keep SSE connections alive when tab is hidden (default: false)\n</code></pre>"},{"location":"reference/90_running/#page-configuration","title":"Page Configuration","text":"<pre><code>(weave/run my-view\n  {:title \"My Application\"                             ; Page title\n   :head [:meta {:name \"description\" \n                 :content \"My app description\"}]       ; Additional HTML for head section\n   :view-port \"width=device-width, initial-scale=1\"})  ; Viewport meta tag\n</code></pre>"},{"location":"reference/90_running/#security-options","title":"Security Options","text":"<pre><code>(weave/run my-view\n  {:csrf-secret \"my-secret-key\"        ; Secret for CSRF token generation\n   :jwt-secret \"my-jwt-secret\"         ; Secret for JWT token generation/validation\n   :handler-options {:auth-required? true}}) ; Require authentication for all handlers by default\n</code></pre>"},{"location":"reference/90_running/#custom-routes-and-middleware","title":"Custom Routes and Middleware","text":"<pre><code>(require '[compojure.core :refer [GET POST]])\n\n(weave/run my-view\n  {:handlers [(GET \"/api/status\" [] {:status 200 :body \"OK\"})\n              (POST \"/api/data\" req (handle-data req))]\n   :middleware [my-logging-middleware\n                my-cors-middleware]})\n</code></pre>"},{"location":"reference/90_running/#progressive-web-app-pwa-configuration","title":"Progressive Web App (PWA) Configuration","text":"<pre><code>(weave/run my-view\n  {:icon \"icons/app-icon.png\"          ; Path to icon file in classpath (PNG format)\n   :pwa {:name \"My Application\"        ; Application name (defaults to :title)\n         :short-name \"MyApp\"           ; Application shortname (defaults to :name)\n         :description \"A great app\"    ; Application description\n         :display \"standalone\"         ; Display mode (default: \"standalone\")\n         :background-color \"#f2f2f2\"   ; Background color (default: \"#f2f2f2\")\n         :theme-color \"#ffffff\"        ; Theme color (default: \"#ffffff\")\n         :start-url \"/\"}})             ; Start URL when launched (default: \"/\")\n</code></pre>"},{"location":"reference/90_running/#complete-example","title":"Complete Example","text":"<pre><code>(ns my-app.core\n  (:require [weave.core :as weave]\n            [compojure.core :refer [GET]]\n            [integrant.core :as ig]))\n\n(defn my-view []\n  [:div\n   [:h1 \"My Weave Application\"]\n   [:button {:data-on-click (weave/handler []\n                              (weave/push-html! \"body\" [:p \"Button clicked!\"]))}\n    \"Click me\"]])\n\n(def app\n  (weave/run my-view\n    {:title \"My App\"\n     :http-kit {:port 3000}\n     :nrepl {:port 7888}\n     :sse {:enabled true\n           :keep-alive true}\n     :handlers [(GET \"/healthz\" [] {:status 200 :body \"healthy\"})]\n     :icon \"icons/app.png\"\n     :pwa {:name \"My Application\"\n           :description \"A sample Weave application\"}}))\n\n;; To stop the server:\n;; (ig/halt! app)\n</code></pre>"},{"location":"reference/90_running/#health-check-endpoint","title":"Health Check Endpoint","text":"<p>Weave automatically provides a health check endpoint at <code>/health</code> that returns:</p> <pre><code>{\"status\":\"ok\"}\n</code></pre> <p>This can be used for container orchestration health checks and load balancer monitoring.</p>"},{"location":"reference/91_testing/","title":"Testing Applications","text":"<p>Weave provides a dedicated browser testing component that simplifies end-to-end testing of Weave applications. The component integrates with Etaoin for browser automation and provides convenience functions for common testing operations.</p>"},{"location":"reference/91_testing/#setup","title":"Setup","text":""},{"location":"reference/91_testing/#adding-the-test-component","title":"Adding the Test Component","text":"<p>Add the browser testing component to your project's <code>deps.edn</code>:</p> <pre><code>{:aliases\n {:test {:extra-deps {weave/test {:git/url \"https://github.com/nakkaya/weave/\"\n                                  :deps/root \"components/test\"}\n                      }}}}\n</code></pre>"},{"location":"reference/91_testing/#prerequisites","title":"Prerequisites","text":"<p>Install ChromeDriver for browser automation:</p> <pre><code># On macOS with Homebrew\nbrew install chromedriver\n\n# On Ubuntu/Debian\nsudo apt-get install chromium-chromedriver\n\n# On other systems, download from:\n# https://chromedriver.chromium.org/\n</code></pre>"},{"location":"reference/91_testing/#basic-usage","title":"Basic Usage","text":""},{"location":"reference/91_testing/#import-the-testing-functions","title":"Import the Testing Functions","text":"<pre><code>(ns my-app.test\n  (:require [clojure.test :refer [deftest testing is]]\n            [weave.test.browser :refer [with-browser visible? click]]))\n</code></pre>"},{"location":"reference/91_testing/#writing-your-first-test","title":"Writing Your First Test","text":"<pre><code>(defn my-test-view []\n  [:div\n   [:h1 {:id \"title\"} \"Hello, Weave!\"]\n   [:button {:id \"click-me\"\n             :data-on-click (weave/handler []\n                              (weave/push-html!\n                                [:h1 {:id \"title\"} \"Clicked!\"]))}\n    \"Click Me\"]])\n\n(deftest basic-interaction-test\n  (with-browser my-test-view {:http-kit {:port 3333}}\n    (testing \"button click updates title\"\n      (visible? :title)\n      (is (= \"Hello, Weave!\" (el-text :title)))\n      (click :click-me)\n      (is (= \"Clicked!\" (el-text :title))))))\n</code></pre>"},{"location":"reference/91_testing/#testing-functions","title":"Testing Functions","text":""},{"location":"reference/91_testing/#core-functions","title":"Core Functions","text":""},{"location":"reference/91_testing/#with-browser","title":"<code>with-browser</code>","text":"<p>Macro that sets up a test server and browser driver for testing.</p> <pre><code>(with-browser view-fn server-options\n  ;; test body with access to *browser* binding\n  )\n</code></pre> <p>Parameters:</p> <ul> <li><code>view-fn</code> - Function that returns your Hiccup view</li> <li><code>server-options</code> - Map of Weave server options (same as <code>weave.core/run</code>)</li> </ul> <p>Features:</p> <ul> <li>Automatically starts Weave server</li> <li>Launches headless Chrome browser</li> <li>Navigates to test URL</li> <li>Provides <code>*browser*</code> binding for test functions</li> <li>Cleans up server and browser after test</li> </ul>"},{"location":"reference/91_testing/#visible","title":"<code>visible?</code>","text":"<p>Waits for an element to be visible and asserts its presence.</p> <pre><code>(visible? :my-element-id)\n</code></pre>"},{"location":"reference/91_testing/#click","title":"<code>click</code>","text":"<p>Clicks an element by ID.</p> <pre><code>(click :button-id)\n</code></pre>"},{"location":"reference/91_testing/#fill","title":"<code>fill</code>","text":"<p>Fills a form field with a value.</p> <pre><code>(fill :input-field \"some text\")\n</code></pre>"},{"location":"reference/91_testing/#el-text","title":"<code>el-text</code>","text":"<p>Gets the text content of an element.</p> <pre><code>(is (= \"Expected Text\" (el-text :element-id)))\n</code></pre>"},{"location":"reference/91_testing/#multi-tab-testing-functions","title":"Multi-Tab Testing Functions","text":""},{"location":"reference/91_testing/#new-tab","title":"<code>new-tab</code>","text":"<p>Opens a new browser tab with the same test URL.</p> <pre><code>(new-tab)\n</code></pre>"},{"location":"reference/91_testing/#tabs","title":"<code>tabs</code>","text":"<p>Returns all browser tab handles.</p> <pre><code>(let [tab-handles (tabs)]\n  ;; tab-handles is a vector of tab identifiers\n  )\n</code></pre>"},{"location":"reference/91_testing/#switch-tab","title":"<code>switch-tab</code>","text":"<p>Switches to a specific tab.</p> <pre><code>(let [[tab1 tab2] (tabs)]\n  (switch-tab tab2)  ; Switch to second tab\n  ;; perform actions in tab2\n  (switch-tab tab1)  ; Switch back to first tab\n  )\n</code></pre>"},{"location":"reference/91_testing/#examples","title":"Examples","text":""},{"location":"reference/91_testing/#testing-form-interactions","title":"Testing Form Interactions","text":"<pre><code>(defn contact-form-view []\n  [:form\n   [:input {:id \"name\" :type \"text\" :placeholder \"Name\"}]\n   [:input {:id \"email\" :type \"email\" :placeholder \"Email\"}]\n   [:button {:id \"submit\"\n             :data-on-click (weave/handler []\n                              (let [{:keys [name email]} (:params weave/*request*)]\n                                (weave/push-html! \"#result\"\n                                  [:div {:id \"result\"}\n                                   (str \"Hello \" name \" (\" email \")\")])))}\n    \"Submit\"]])\n\n(deftest form-submission-test\n  (with-browser contact-form-view {:http-kit {:port 3333}}\n    (testing \"form submission displays result\"\n      (visible? :name)\n      (fill :name \"John Doe\")\n      (fill :email \"john@example.com\")\n      (click :submit)\n      (visible? :result)\n      (is (= \"Hello John Doe (john@example.com)\" (el-text :result))))))\n</code></pre>"}]}