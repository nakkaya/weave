/**
 * Minified by jsDelivr using Terser v5.39.0.
 * Original file: /npm/squint-cljs@0.9.182/src/squint/core.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function toFn(e){if(null==e)return e;if(e instanceof Function)return e;const n=typeof e;return"string"===n?(n,r)=>get(n,e,r):"object"===n?(n,r)=>get(e,n,r):e}var has=Object.prototype.hasOwnProperty;function findKey(e,n,r){for(r of e.keys())if(dequal(r,n))return r}function dequal(e,n){if(e===n)return!0;var r,o,u;if(e&&n&&(r=e.constructor)===n.constructor){if(r===Array){if((o=e.length)===n.length)for(;o--&&dequal(e[o],n[o]););return-1===o}if(r===Set){if(e.size!==n.size)return!1;for(const r of e){if((u=r)&&"object"==typeof u&&!(u=findKey(n,u)))return!1;if(!n.has(u))return!1}return!0}if(r===Map){if(e.size!==n.size)return!1;for(const r of e){if((u=r[0])&&"object"==typeof u&&!(u=findKey(n,u)))return!1;if(!dequal(r[1],n.get(u)))return!1}return!0}if(!r||"object"==typeof e){o=0;for(const r in e){if(has.call(e,r)&&++o&&!has.call(n,r))return!1;if(!(r in n)||!dequal(e[r],n[r]))return!1}return Object.keys(n).length===o}}return!1}function walkArray(e,n){return e.every((function(r,o){return 0===o||n(e[o-1],r)}))}export function _EQ_(...e){return walkArray(e,((e,n)=>dequal(e,n)))}export function _GT_(...e){return walkArray(e,((e,n)=>e>n))}export function _GT__EQ_(...e){return walkArray(e,((e,n)=>e>=n))}export function _LT_(...e){return walkArray(e,((e,n)=>e<n))}export function _LT__EQ_(...e){return walkArray(e,((e,n)=>e<=n))}export function _PLUS_(...e){return e.reduce(((e,n)=>e+n),0)}export function _STAR_(...e){return e.reduce(((e,n)=>e*n),1)}export function _(...e){return 1==e.length?0-e[0]:e.reduce(((e,n)=>e-n))}export const __protocol_satisfies={};export function satisfies_QMARK_(e,n){return null==n?e.null:"symbol"==typeof e?n[e]:n[e.__sym]}function mapAssocMut(e,n,r){return e.set(n,r),e}function objAssocMut(e,n,r){return e[n]=r,e}function getAssocMut(e){switch(typeConst(e)){case MAP_TYPE:return mapAssocMut;case ARRAY_TYPE:case OBJECT_TYPE:return objAssocMut}}export function assoc_BANG_(e,n,r,...o){if(o.length%2!=0)throw new Error("Illegal argument: assoc expects an odd number of arguments.");switch(typeConst(e)){case MAP_TYPE:e.set(n,r);for(let n=0;n<o.length;n+=2)e.set(o[n],o[n+1]);break;case ARRAY_TYPE:case OBJECT_TYPE:e[n]=r;for(let n=0;n<o.length;n+=2)e[o[n]]=o[n+1];break;default:throw new Error(`Illegal argument: assoc! expects a Map, Array, or Object as the first argument, but got ${typeof e}.`)}return e}function copy(e){switch(typeConst(e)){case MAP_TYPE:return new Map(e);case SET_TYPE:return new e.constructor(e);case ARRAY_TYPE:return[...e];case OBJECT_TYPE:return{...e};default:throw new Error(`Don't know how to copy object of type ${typeof e}.`)}}export function assoc(e,n,r,...o){e||(e={});const u=copy(e);return assoc_BANG_(u,n,r,...o),u}const MAP_TYPE=1,ARRAY_TYPE=2,OBJECT_TYPE=3,LIST_TYPE=4,SET_TYPE=5,LAZY_ITERABLE_TYPE=6;function emptyOfType(e){switch(e){case MAP_TYPE:return new Map;case ARRAY_TYPE:return[];case OBJECT_TYPE:return{};case LIST_TYPE:return new List;case SET_TYPE:return new Set;case LAZY_ITERABLE_TYPE:return lazy((function*(){}))}}function isObj(e){return e.constructor===Object}export function object_QMARK_(e){return null!=e&&isObj(e)}function typeConst(e){if(null!=e)return isObj(e)?OBJECT_TYPE:e instanceof Map?MAP_TYPE:e instanceof Set?SET_TYPE:e instanceof List?LIST_TYPE:Array.isArray(e)?ARRAY_TYPE:e instanceof LazyIterable?LAZY_ITERABLE_TYPE:e instanceof SortedSet?SET_TYPE:e instanceof Object?OBJECT_TYPE:void 0}function assoc_in_with(e,n,r,o,u){o=vec(o);const i=typeConst(r=r||{});if(i!==MAP_TYPE&&i!==ARRAY_TYPE&&i!==OBJECT_TYPE)throw new Error(`Illegal argument: ${n} expects the first argument to be a Map, Array, or Object.`);const c=[r];let s=r;for(let e=0;e<o.length-1;e+=1){const n=o[e];let r;r=s instanceof Map?s.get(n):s[n],r||(r=emptyOfType(i)),c.push(r),s=r}c.push(u);for(let n=c.length-2;n>=0;n-=1)c[n]=e(c[n],o[n],c[n+1]);return c[0]}export function assoc_in(e,n,r){return assoc_in_with(assoc,"assoc-in",e,n,r)}export function assoc_in_BANG_(e,n,r){n=vec(n);var o=e;const u=typeConst(e);for(const e of n.splice(0,n.length-1)){let n=get(o,e);void 0===n&&(n=emptyOfType(u),assoc_BANG_(o,e,n)),o=n}return assoc_BANG_(o,n[n.length-1],r),e}export function comp(...e){if(0===(e=e.map(toFn)).length)return identity;if(1===e.length)return e[0];const[n,...r]=e.slice().reverse();return function(...e){let o=n(...e);for(const e of r)o=e(o);return o}}function conj_BANG_set(e,n){for(const r of n)e.add(r);return e}export function conj_BANG_(...e){if(0===e.length)return vector();const[n,...r]=e;let o=n;switch(null==o&&(o=[]),typeConst(o)){case SET_TYPE:conj_BANG_set(o,r);break;case LIST_TYPE:o.unshift(...r.reverse());break;case ARRAY_TYPE:o.push(...r);break;case MAP_TYPE:for(const e of r)Array.isArray(e)?o.set(e[0],e[1]):iterable(e).forEach((e=>{o.set(e[0],e[1])}));break;case OBJECT_TYPE:for(const e of r)Array.isArray(e)?o[e[0]]=e[1]:Object.assign(o,e);break;default:throw new Error("Illegal argument: conj! expects a Set, Array, List, Map, or Object as the first argument.")}return o}export function conj(...e){if(0===e.length)return vector();const[n,...r]=e;let o,u,i=n;switch(null==i&&(i=list()),typeConst(i)){case SET_TYPE:return i instanceof SortedSet?conj_BANG_set(new i.constructor(i),r):new i.constructor([...i,...r]);case LIST_TYPE:return new List(...r.reverse(),...i);case ARRAY_TYPE:return[...i,...r];case MAP_TYPE:o=new Map(i);for(const e of r)Array.isArray(e)?o.set(e[0],e[1]):iterable(e).forEach((e=>{o.set(e[0],e[1])}));return o;case LAZY_ITERABLE_TYPE:return lazy((function*(){yield*r,yield*i}));case OBJECT_TYPE:u={...i};for(const e of r)Array.isArray(e)?u[e[0]]=e[1]:Object.assign(u,e);return u;default:throw new Error("Illegal argument: conj expects a Set, Array, List, Map, or Object as the first argument.")}}export function disj_BANG_(e,...n){for(const r of n)e.delete(r);return e}export function disj(e,...n){return disj_BANG_(new e.constructor([...e]),...n)}export function contains_QMARK_(e,n){switch(typeConst(e)){case SET_TYPE:case MAP_TYPE:return e.has(n);case void 0:return!1;default:return n in e}}export function dissoc_BANG_(e,...n){for(const r of n)delete e[r];return e}export function dissoc(e,...n){if(!e)return;if(0===n.length)return e;const r=copy(e);if(typeConst(e)===MAP_TYPE)for(const e of n)r.delete(e);else for(const e of n)delete r[e];return r}export function inc(e){return e+1}export function dec(e){return e-1}export function println(...e){console.log(...e)}export function nth(e,n,r){if(e){var o=void 0;if(Array.isArray(e))o=e[n];else{const r=iterable(e);let u=0;for(const e of r)if(u++==n){o=e;break}}if(void 0!==o)return o}return r}export function get(e,n,r=void 0){if(null==e)return r;let o,u;if(isObj(e))return o=e[n],void 0===o?r:o;switch(typeConst(e)){case SET_TYPE:e.has(n)&&(o=n);break;case MAP_TYPE:o=e.get(n);break;case ARRAY_TYPE:o=e[n];break;default:if(u=e.get,u instanceof Function)try{o=e.get(n);break}catch(e){}o=e[n]}return void 0!==o?o:r}export function seq_QMARK_(e){return null!=e&&!!e[Symbol.iterator]}export const sequential_QMARK_=seq_QMARK_;export function seqable_QMARK_(e){return null==e||!!e[Symbol.iterator]}export function iterable(e){if(null==e)return[];if(seqable_QMARK_(e))return e;if(e instanceof Object)return Object.entries(e);throw new TypeError(`${e} is not iterable`)}export const IIterable=Symbol("Iterable");export const IIterable__iterator=Symbol.iterator;export function _iterator(e){return e[Symbol.iterator]()}export const es6_iterator=_iterator;export function seq(e){if(null==e)return e;const n=iterable(e);if(0===n.length||0===n.size)return null;return n[Symbol.iterator]().next().done?null:n}export function first(e){const[n]=iterable(e);return n}export function second(e){const[n,r]=iterable(e);return r}export function ffirst(e){return first(first(e))}export function rest(e){return lazy((function*(){let n=!0;for(const r of iterable(e))n?n=!1:yield r}))}class Reduced{value;constructor(e){this.value=e}_deref(){return this.value}}export function last(e){let n;if(typeConst(e=iterable(e))===ARRAY_TYPE)return e[e.length-1];for(const r of e)n=r;return n}export function reduced(e){return new Reduced(e)}export function reduced_QMARK_(e){return e instanceof Reduced}export function reduce(e,n,r){let o,u;if(e=toFn(e),2===arguments.length){const r=iterable(n)[Symbol.iterator](),i=r.next();u=i.done?e():i.value,o=r}else u=n,o=iterable(r);if(u instanceof Reduced)return u.value;for(const n of o)if(u=e(u,n),u instanceof Reduced){u=u.value;break}return u}function*_reductions2(e,n){const r=n.next();r.done?yield e():yield*_reductions3(e,r.value,n)}function*_reductions3(e,n,r){let o=n,u=r;for(;;){if(reduced_QMARK_(o))return void(yield o.value);yield o;const n=u.next();if(n.done)break;o=e(o,n.value)}}export function reductions(e,n,r){return e=toFn(e),lazy(2===arguments.length?function*(){yield*_reductions2(e,iterable(n)[Symbol.iterator]())}:function*(){yield*_reductions3(e,n,iterable(r)[Symbol.iterator]())})}var tolr=!1;export function warn_on_lazy_reusage_BANG_(){tolr=!0}class LazyIterable{constructor(e){this.gen=e,this.usages=0}[Symbol.iterator](){if(this.usages++,this.usages>=2&&tolr)try{throw new Error}catch(e){console.warn("Re-use of lazy value",e.stack)}return this.gen()}}LazyIterable.prototype[IIterable]=!0;export function lazy(e){return new LazyIterable(e)}export class Cons{constructor(e,n){this.x=e,this.coll=n}*[Symbol.iterator](){yield this.x,yield*iterable(this.coll)}}export function cons(e,n){return new Cons(e,n)}export function map(e,...n){switch(e=toFn(e),n.length){case 0:return n=>(...r)=>{switch(r.length){case 0:return n();case 1:return n(r[0]);case 2:return n(r[0],e(r[1]));default:return n(r[0],e(...r.slice(1)))}};case 1:return lazy((function*(){for(const r of iterable(n[0]))yield e(r)}));default:return lazy((function*(){const r=n.map((e=>es6_iterator(iterable(e))));for(;;){const n=[];for(const e of r){const r=e.next();if(r.done)return;n.push(r.value)}yield e(...n)}}))}}function filter1(e){return n=>(...r)=>{switch(r.length){case 0:return n();case 1:return n(r[0]);case 2:{const o=r[0],u=r[1];return truth_(e(u))?n(o,u):o}}}}export function filter(e,n){return 1===arguments.length?filter1(e):(e=toFn(e),lazy((function*(){for(const r of iterable(n))truth_(e(r))&&(yield r)})))}export function filterv(e,n){return[...filter(e,n)]}export function remove(e,n){return 1===arguments.length?filter1(complement(e)):filter(complement(e),n)}function map_indexed1(e){return n=>{let r=-1;return(...o)=>{switch(o.length){case 0:return n();case 1:return n(o[0]);case 2:return n(o[0],e((r+=1,r),o[1]))}}}}export function map_indexed(e,n){return e=toFn(e),1===arguments.length?map_indexed1(e):lazy((function*(){let r=0;for(const o of iterable(n))yield e(r,o),r++}))}function keep_indexed2(e,n){return e=toFn(e),lazy((function*(){let r=0;for(const o of iterable(n)){const n=e(r,o);truth_(n)&&(yield n),r++}}))}function keep_indexed1(e){return n=>{let r=-1;return(...o)=>{const u=o.length;if(0===u)return n();if(1===u)return n(o[0]);if(2===u){const u=o[0],i=o[1];r++;const c=e(r,i);return null==c?u:n(u,c)}}}}export function keep_indexed(e,n){return 1===arguments.length?keep_indexed1(e):keep_indexed2(e,n)}export function str(...e){return e.join("")}export function not(e){return!truth_(e)}export function nil_QMARK_(e){return null==e}export const PROTOCOL_SENTINEL={};export class Atom{constructor(e){this.val=e,this._watches={},this._deref=()=>this.val,this._hasWatches=!1,this._reset_BANG_=e=>{const n=this.val;if(this.val=e,this._hasWatches)for(const r of Object.entries(this._watches)){const o=r[0];(0,r[1])(o,this,n,e)}return e},this._add_watch=(e,n)=>{this._watches[e]=n,this._hasWatches=!0},this._remove_watch=e=>{delete this._watches[e]}}}export function atom(e){return new Atom(e)}export function deref(e){return e._deref()}export function reset_BANG_(e,n){e._reset_BANG_(n)}export function swap_BANG_(e,n,...r){const o=(n=toFn(n))(deref(e),...r);return reset_BANG_(e,o),o}export function range(e,n,r){return lazy((function*(){let o=e,u=n,i=r;void 0===n&&(o=0,u=e);let c=o||0;i=r??1;const s=i>=0;for(;void 0===u||s&&c<u||!s&&u<c;)yield c,c+=i}))}export function re_matches(e,n){const r=e.exec(n);return r&&n===r[0]?1===r.length?r[0]:r:null}export function re_find(e,n){if(string_QMARK_(n)){const r=e.exec(n);return null!=r?1===r.length?r[0]:[...r]:null}throw new TypeError("re-find must match against a string.")}export function re_pattern(e){if(e instanceof RegExp)return e;const n=e.match(/^\(\?([dgimsuvy]*)\)/);return n?new RegExp(e.slice(n[0].length),n[1]):new RegExp(e)}export function subvec(e,n,r){return e.slice(n,r)}export function vector(...e){return e}export const array=vector;export function vector_QMARK_(e){return typeConst(e)===ARRAY_TYPE}export function mapv(...e){if(2===e.length){const[o,u]=e,i=toFn(o),c=iterable(u);if(Array.isArray(c)){const e=new Array(c.length);for(var n=0;n<c.length;n++)e[n]=i(c[n]);return e}var r=[];for(const e of c)r.push(i(e));return r}return[...map(...e)]}export function vec(e){return array_QMARK_(e)?e:[...iterable(e)]}export function set(e){return new Set(iterable(e))}export function set_QMARK_(e){return typeConst(e)===SET_TYPE}const IApply__apply=Symbol("IApply__apply");export function apply(e,...n){e=toFn(e);const r=n.slice(0,n.length-1),o=iterable(n[n.length-1]),u=e[IApply__apply];return u?u(...r,o):e(...r,...o)}export function even_QMARK_(e){return e%2==0}export function odd_QMARK_(e){return!even_QMARK_(e)}export function complement(e){return e=toFn(e),(...n)=>not(e(...n))}export function constantly(e){return(...n)=>e}class List extends Array{constructor(...e){super(),this.push(...e)}}export function list_QMARK_(e){return typeConst(e)===LIST_TYPE}export function list(...e){return new List(...e)}export function array_QMARK_(e){return Array.isArray(e)}function concat1(e){return lazy((function*(){for(const n of e)yield*iterable(n)}))}export function concat(...e){return concat1(e)}concat[IApply__apply]=e=>concat1(e);export function mapcat(e,...n){if(0===n.length)return comp(map(e),cat);return concat1(map(e,...n))}export function identity(e){return e}export function interleave(...e){return lazy((function*(){const n=e.map((e=>es6_iterator(iterable(e))));for(;;){const e=[];for(const r of n){const n=r.next();if(n.done)return;e.push(n.value)}yield*e}}))}function interpose1(e){return n=>{let r=!1;return(...o)=>{switch(o.length){case 0:return n();case 1:return n(o[0]);case 2:if(r){const r=n(o[0],e);return reduced_QMARK_(r)?r:n(r,o[1])}return r=!0,n(o[0],o[1])}}}}export function interpose(e,n){return 1===arguments.length?interpose1(e):drop(1,interleave(repeat(e),n))}export function select_keys(e,n){const r=emptyOfType(typeConst(e))||{};for(const o of n){const n=get(e,o);null!=n&&assoc_BANG_(r,o,n)}return r}export function unreduced(e){return reduced_QMARK_(e)?deref(e):e}function partition_all1(e){return n=>{let r=[];return(...o)=>{let u,i;switch(o.length){case 0:return n();case 1:return u=o[0],0!==r.length&&(i=[...r],r=[],u=unreduced(n(u,i))),n(u);case 2:return u=o[0],r.push(o[1]),e===r.length?(i=[...r],r=[],n(u,i)):u}}}}export function partition_all(e,...n){if(1===arguments.length)return partition_all1(e);let r=e,o=n[0];return 2===n.length&&([r,o]=n),partitionInternal(e,r,[],o,!0)}export function partition(e,...n){let r=e,o=[],u=n[0];return 2===n.length?[r,u]=n:n.length>2&&([r,o,u]=n),partitionInternal(e,r,o,u,!1)}export const partitionv=partition;export const partitionv_all=partition_all;function partitionInternal(e,n,r,o,u){return lazy((function*(){let i=[],c=0;for(const r of iterable(o))c<e&&(i.push(r),i.length===e&&(yield i,i=n<e?i.slice(n):[])),c++,c===n&&(c=0);i.length>0&&(i.length===e||u?yield i:r.length&&(i.push(...r.slice(0,e-i.length)),yield i))}))}function partition_by1(e){return n=>{let r=[];const o={};let u=o;return(...i)=>{const c=i.length;if(0===c)return n();if(1===c){let e=i[0];if(0!==r.length){const o=[...r];r=[],e=unreduced(n(e,o))}return n(e)}if(2===c){const c=i[0],s=i[1],a=u,f=e(s);if(u=f,a===o||f===a)return r.push(s),c;{const e=[...r];r=[];const o=n(c,e);return reduced_QMARK_(o)||r.push(s),o}}}}}export function partition_by(e,n){return e=toFn(e),1===arguments.length?partition_by1(e):lazy((function*(){const r=es6_iterator(n),o=r.next();o.done&&(yield*null);const u=o.value;let i=e(u),c=[u],s=[];for(;;){const n=r.next();if(n.done){yield c;break}const o=n.value,u=e(o);i==u?c.push(o):(yield c,s.push(o),c=s,i=u,s=[])}}))}export function empty(e){const n=typeConst(e);if(null!=n)return emptyOfType(n);throw new Error("Can't create empty of "+typeof e)}export function merge(...e){const n=e[0];let r;return r=null==n?{}:into(empty(n),n),conj_BANG_(r,...e.slice(1))}export function key(e){return e[0]}export function val(e){return e[1]}export function merge_with(e,...n){e=toFn(e);var r=!1;for(const e of n)if(null!=e){r=!0;break}if(r){const r=(n,r)=>{const o=key(r),u=val(r);return contains_QMARK_(n,o)?assoc(n,o,e(get(n,o),u)):assoc(n,o,u)},o=(e,n)=>reduce(r,e||{},seq(n));return reduce(o,n)}return null}export function system_time(){return performance.now()}export function into(...e){let n,r,o,u,i;switch(e.length){case 0:return[];case 1:return e[0];case 2:return conj(e[0]??[],...iterable(e[1]));case 3:return n=e[0],r=e[1],o=e[2],u=copy(n),i=(e,n)=>void 0===n?e:conj_BANG_(e,n),transduce(r,i,u,o);default:throw TypeError(`Invalid arity call of into: ${e.length}`)}}export function identical_QMARK_(e,n){return e===n}export function repeat(...e){if(0==e.length||e.length>2)throw new Error(`Invalid arity: ${e.length}`);return{[IIterable]:!0,[IIterable__iterator]:1==e.length?function*(){const n=e[0];for(;;)yield n}:function*(){const[n,r]=e;for(var o=0;o<n;o++)yield r}}}export function ensure_reduced(e){return reduced_QMARK_(e)?e:reduced(e)}function take1(e){return n=>{let r=e;return(...e)=>{const o=e.length;if(0===o)return n();if(1===o){const r=e[0];return n(r)}if(2===o){let o=e[0];const u=e[1],i=r,c=(r-=1,r);return i>0&&(o=n(o,u)),c>0?o:ensure_reduced(o)}}}}export function take(e,n){return 1===arguments.length?take1(e):lazy((function*(){let r=e-1;for(const e of iterable(n))if(r-- >=0&&(yield e),r<0)return}))}export function take_last(e,n){if(e<=0)return null;if(Array.isArray(n))return seq(n.slice(-e));{const r=new Array(e);let o=0;for(const u of iterable(n))r[o%e]=u,o++;return o%e!=0&&o>=e?r.slice(o%e).concat(r.slice(0,o%e)):(r.length=Math.min(o,e),r)}}function take_while1(e){return n=>(...r)=>{const o=r.length;if(0===o)return n();if(1===o)return n(r[0]);if(2===o){const o=r[0],u=r[1];return truth_(e(u))?n(o,u):reduced(o)}}}export function take_while(e,n){return e=toFn(e),1===arguments.length?take_while1(e):lazy((function*(){for(const r of iterable(n)){if(!truth_(e(r)))return;yield r}}))}function take_nth1(e){return n=>{let r=-1;return(...o)=>{const u=o.length;if(0===u)return n();if(1===u)return n(o[0]);if(2===u){const u=o[0],i=o[1];r++;return 0===rem(r,e)?n(u,i):u}}}}export function take_nth(e,n){return 1===arguments.length?take_nth1(e):e<=0?repeat(first(n)):lazy((function*(){let r=0;for(const o of iterable(n))r%e==0&&(yield o),r++}))}export function partial(e,...n){return e=toFn(e),function(...r){return e(...n,...r)}}export function cycle(e){return lazy((function*(){for(;;)yield*e}))}function drop1(e){return n=>{let r=e;return(...e)=>{const o=e.length;if(0===o)return n();if(1===o)return n(e[0]);if(2===o){const o=e[0],u=e[1],i=r;return r--,i>0?o:n(o,u)}}}}export function drop(e,n){return 1===arguments.length?drop1(e):lazy((function*(){const r=_iterator(iterable(n));for(let n=0;n<e;n++)r.next();yield*r}))}function drop_while1(e){return n=>{let r=!0;return(...o)=>{const u=o.length;if(0===u)return n();if(1===u)return n(o[0]);if(2===u){const u=r,i=o[0],c=o[1];return u&&truth_(e(c))?i:(r=null,n(i,c))}}}}export function drop_while(e,n){return e=toFn(e),1===arguments.length?drop_while1(e):lazy((function*(){const r=_iterator(iterable(n));for(;;){const n=r.next();if(n.done)break;const o=n.value;if(!truth_(e(o))){yield o;break}}yield*r}))}function distinct1(){return e=>{const n=new Set;return(...r)=>{const o=r.length;if(0===o)return e();if(1===o)return e(r[0]);if(2===o){const o=r[0],u=r[1];return n.has(u)?o:(n.add(u),e(o,u))}}}}export function distinct(e){return 0===arguments.length?distinct1():lazy((function*(){const n=new Set;for(const r of iterable(e))n.has(r)||(yield r),n.add(r)}))}export function update(e,n,r,...o){return assoc(e,n,(r=toFn(r))(get(e,n),...o))}export function get_in(e,n,r){let o=e;for(const e of n)o=get(o,e);return void 0===o?r:o}export function update_in(e,n,r,...o){return assoc_in(e,n,(r=toFn(r))(get_in(e,n),...o))}export function fnil(e,n,...r){return e=toFn(e),function(o,...u){return o?e(o,...r,...u):e(n,...r,...u)}}export function every_QMARK_(e,n){e=toFn(e);for(const r of iterable(n))if(!e(r))return!1;return!0}export function not_every_QMARK_(e,n){return!every_QMARK_(e,n)}function keep1(e){return n=>(...r)=>{const o=r.length;if(0===o)return n();if(1===o)return n(r[0]);if(2===o){const o=r[0],u=r[1],i=e(u);return null==i?o:n(o,i)}}}export function keep(e,n){return e=toFn(e),1===arguments.length?keep1(e):lazy((function*(){for(const r of iterable(n)){const n=e(r);truth_(n)&&(yield n)}}))}export function reverse(e){return e=iterable(e),[...e].reverse()}export function sort(e,n){1===arguments.length&&(n=e,e=void 0),e=toFn(e),n=iterable(n);return[...n].sort(e||compare)}function fnToComparator(e){return e===compare?e:(n,r)=>{const o=e(n,r);return number_QMARK_(o)?o:o?-1:e(r,n)?1:0}}export function sort_by(e,n,r){return 2===arguments.length&&(r=n,n=compare),e=toFn(e),n=toFn(n),sort(((r,o)=>fnToComparator(n)(e(r),e(o))),r)}export function shuffle(e){const n=[...e];let r=e.length;for(;r;){const e=Math.floor(Math.random()*r--),o=n[r];n[r]=n[e],n[e]=o}return n}export function some(e,n){e=toFn(e);for(const r of iterable(n)){const n=e(r);if(truth_(n))return n}}export function not_any_QMARK_(e,n){return!some(e=toFn(e),n)}export function replace(e,n){return(Array.isArray(n)?mapv:map)((n=>{const r=e[n];return void 0!==r?r:n}),n)}export function empty_QMARK_(e){return!seq(e)}export function rand(e){return void 0===e&&(e=1),Math.random()*e}export function rand_int(e){return Math.floor(Math.random()*e)}export function rand_nth(e){return nth(e,rand_int(count(e)))}function _repeatedly(e){return lazy((function*(){for(;;)yield e()}))}export function repeatedly(e,n){1===arguments.length&&(n=e,e=void 0);const r=_repeatedly(n);return e?take(e,r):r}export function update_BANG_(e,n,r,...o){return assoc_BANG_(e,n,(r=toFn(r))(get(e,n),...o))}export function group_by(e,n){e=toFn(e);const r={};for(const o of iterable(n)){update_BANG_(r,e(o),fnil(conj_BANG_,[]),o)}return r}export function frequencies(e){const n={},r=fnil(inc,0);for(const o of iterable(e))update_BANG_(n,o,r);return n}export class LazySeq{constructor(e){this.f=e,this.res=void 0}*[Symbol.iterator](){void 0===this.res&&(this.res=this.f(),this.f=null),yield*iterable(this.res)}}export function butlast(e){const n=[...iterable(e)];return n.pop(),n.length>0?n:null}export function drop_last(...e){const[n,r]=e.length>1?e:[1,e[0]];return map(((e,n)=>e),r,drop(n,r))}export function split_at(e,n){return[take(e,n),drop(e,n)]}export function split_with(e,n){return[take_while(e,n),drop_while(e,n)]}export function count(e){if(!e)return 0;const n=e.length||e.size;if("number"==typeof n)return n;let r=0;for(const n of iterable(e))r++;return r}export function true_QMARK_(e){return!0===e}export function false_QMARK_(e){return!1===e}export function some_QMARK_(e){return!(null==e)}export function boolean$(e){return!!e}export function zero_QMARK_(e){return 0===e}export function neg_QMARK_(e){return e<0}export function pos_QMARK_(e){return e>0}export function js_obj(...e){let n=0;const r={};for(;!(n>=e.length);)r[e[n]]=e[n+1],n+=2;return r}export function alength(e){return e.length}export function aset(e,n,r,...o){if(0==o.length)return e[n]=r,r;{const u=[n,r,...o],i=u[u.length-1];let c=e,s=0;const a=u.length-2;for(;s<a;s++)c=c[u[s]];return c[u[s]]=i,r}}export function dorun(e){for(const n of iterable(e));return null}export function doall(e){return vec(e)}export function aclone(e){return[...e]}export function add_watch(e,n,r){return e._add_watch(n,r)}export function remove_watch(e,n){return e._remove_watch(n)}export function reduce_kv(e,n,r){if(!r)return n;var o=n;for(const n of iterable(r))o=e(o,n[0],n[1]);return o}export function max(e,n,...r){return null==n?e:Math.max(e,n,...r)}export function min(e,n,...r){return null==n?e:Math.min(e,n,...r)}export function map_QMARK_(e){return null!=e&&(!!isObj(e)||e instanceof Map)}export function every_pred(...e){return(...n)=>{for(const r of e)for(const e of n){if(!r(e))return!1}return!0}}export function some_fn(...e){return(...n)=>{for(const r of e)for(const e of n){const n=r(e);if(n)return n}}}export function into_array(e,n){return vec(n||e)}export function iterate(e,n){var r=n;return lazy((function*(){for(;;)yield r,r=e(r)}))}export function juxt(...e){return e=e.map(toFn),(...n)=>{const r=[];for(const o of e)r.push(o(...n));return r}}export function next(e){if(Array.isArray(e)){const n=e.slice(1);return n.length>0?n:null}return seq(rest(e))}export function nnext(e){return next(next(e))}export function compare(e,n){if(e===n)return 0;{if(null==e)return-1;if(null==n)return 1;const r=typeof e,o=typeof n;if("number"===r&&"number"===o||"string"===r&&"string"===o)return e===n?0:e<n?-1:1;if(Array.isArray(e)&&Array.isArray(n)){if(e.length<n.length)return-1;if(e.length>n.length)return 1;for(let r=0;r<e.length;r++){const o=compare(e[r],n[r]);if(0!=o)return o}return 0}throw new Error(`comparing ${r} to ${o}`)}}export function to_array(e){return into_array(e)}export function truth_(e){return null!=e&&!1!==e}export const t=truth_;export function subs(e,n,r){return e.substring(n,r)}export function fn_QMARK_(e){return"function"==typeof e}export function re_seq(e,n){return lazy((function*(){for(;;){const r=e.exec(n);if(!r)break;{const e=r[0],o=1===r.length?e:vec(r);yield o;const u=r.index+max(1,e.length);if(u>n.length)break;n=subs(n,u)}}}))}export function NaN_QMARK_(e){return Number.isNaN(e)}export function number_QMARK_(e){return"number"==typeof e}export function keys(e){if(null==e)return;switch(typeConst(e)){case OBJECT_TYPE:return Object.keys(e);case MAP_TYPE:return Array.from(e.keys())}}export function js_keys(e){return keys(e)}export function vals(e){if(null==e)return;switch(typeConst(e)){case OBJECT_TYPE:return Object.values(e);case MAP_TYPE:return Array.from(e.values())}}export function string_QMARK_(e){return"string"==typeof e}export function coll_QMARK_(e){return null!=typeConst(e)}export function regexp_QMARK_(e){return e instanceof RegExp}class ExceptionInfo extends Error{constructor(e,n,r){super(e),this._data=n,this._cause=r}}export function ex_data(e){return e instanceof ExceptionInfo?e._data:null}export function ex_message(e){return e instanceof Error?e.message:null}export function ex_cause(e){return e instanceof ExceptionInfo?e._cause:null}export function ex_info(e,n,r){return new ExceptionInfo(e,n,r)}export function int_QMARK_(e){return Number.isInteger(e)}export const integer_QMARK_=int_QMARK_;export function pos_int_QMARK_(e){return int_QMARK_(e)&&e>0}export function nat_int_QMARK_(e){return int_QMARK_(e)&&e>-1}export function neg_int_QMARK_(e){return int_QMARK_(e)&&e<0}const _metaSym=Symbol("meta");export function meta(e){return e instanceof Object?e[_metaSym]:null}export function with_meta(e,n){const r=copy(e);return r[_metaSym]=n,r}export function boolean_QMARK_(e){return!0===e||!1===e}export function counted_QMARK_(e){switch(typeConst(e)){case ARRAY_TYPE:case MAP_TYPE:case OBJECT_TYPE:case LIST_TYPE:case SET_TYPE:return!0}return!1}export function bounded_count(e,n){return counted_QMARK_(n)?count(n):count(take(e,n))}export function find(e,n){const r=get(e,n);if(void 0!==r)return[n,r]}export function mod(e,n){return(e%n+n)%n}export function min_key(e,n,...r){if(0==r.length)return n;var o=e(n),u=n;return r.forEach((n=>{var r=e(n);r<=o&&(o=r,u=n)})),u}export function max_key(e,n,...r){if(0==r.length)return n;var o=e(n),u=n;return r.forEach((n=>{var r=e(n);r>=o&&(o=r,u=n)})),u}function parsing_err(e){throw new Error("Expected string, got: "+typeof e)}export function parse_long(e){if(string_QMARK_(e)){if(/^[+-]?\d+$/.test(e)){const n=parseInt(e);if(Number.MIN_SAFE_INTEGER<=n<=Number.MAX_SAFE_INTEGER)return n}return null}return parsing_err(e)}export function parse_double(e){if(string_QMARK_(e))return/^[\\x00-\\x20]*[+-]?NaN[\\x00-\\x20]*$/.test(e)?NaN:/^[\\x00-\\x20]*[+-]?(Infinity|((\d+\.?\d*|\.\d+)([eE][+-]?\d+)?)[dDfF]?)[\\x00-\\x20]*$/.test(e)?parseFloat(e):null;throw new parsing_err(e)}function fix(e){return e>=0?Math.floor(e):Math.ceil(e)}export function quot(e,n){return fix((e-e%n)/n)}export function trampoline(e,...n){if(0!=n.length)return trampoline((function(){return apply(e,n)}));for(;;){const n=e();if(!truth_(fn_QMARK_(n)))return n;e=n}}export function transduce(e,...n){if(2===n.length){const r=n[0],o=n[1];return transduce(e,r,r(),o)}{let r=n[0];const o=n[1],u=n[2];r=e(r);return r(reduce(r,o,u))}}export function zipmap(e,n){const r={},o=iterable(e)[Symbol.iterator](),u=iterable(n)[Symbol.iterator]();let i,c;for(;(i=o.next(),!i.done)&&(c=u.next(),!c.done);)r[i.value]=c.value;return r}export function not_empty(e){return seq(e)?e:null}export function tree_seq(e,n,r){const o=function*(r){if(yield r,truth_(e(r)))for(const e of iterable(n(r)))yield*o(e)};return lazy((function*(){yield*o(r)}))}export function flatten(e){return filter(complement(sequential_QMARK_),rest(tree_seq(sequential_QMARK_,seq,e)))}export function transient$(e){return copy(e)}export function persistent_BANG_(e){return Object.freeze(e)}class SortedSet{constructor(e){e instanceof SortedSet||(e=sort(e));const n=new Set(e);this._elts=[...n],this._set=n}add(e){if(this._set.has(e))return this;const n=this._elts;let r=!1;for(let o=0;o<n.length;o++)if(compare(e,n[o])<=0){n.splice(o,0,e),r=!0;break}return r?this._set=new Set(n):(n.push(e),this._set.add(e)),this.size=n.length,this}delete(e){if(!this._set.has(e))return this;const n=this._elts,r=n.indexOf(e);return n.splice(r,1),this._set=new Set(n),this.size=n.length,this}has(e){return this._set.has(e)}keys(){return this.values()}values(){return this._elts[Symbol.iterator]()}entries(){return this._set.entries()}forEach(...e){return this.set.forEach(...e)}clear(){this._elts=[],this._set=new Set(this._elts)}[Symbol.iterator](){return this.keys()}}export function sorted_set(...e){return new SortedSet(e)}function mkBoundFn(e,n,r){return e=>n(compare(e,r),0)}function indexFrom(e,n,r=!0){let o=0;for(;o<e.length&&compare(n,e[o])>0;o++);return o}function subseq3([e,n,r]){const o=mkBoundFn(e,n,r);if(n===_GT_||n===_GT__EQ_){const n=[...e],u=indexFrom(n,r,!0);return n.splice(0,u),o(n[0])||n.splice(0,1),n}return[...take_while(o,e)]}function subseq5([e,n,r,o,u]){const i=[...e],c=indexFrom(i,r,!0);i.splice(0,c);const s=mkBoundFn(e,o,u);return mkBoundFn(e,n,r)(i[0])||i.splice(0,1),[...take_while(s,i)]}export function subseq(...e){return 3===e.length?subseq3(e):5===e.length?subseq5(e):void 0}export function abs(e){return Math.abs(e)}export function long$(e){return fix(e)}export function type(e){return null!=e&&e.constructor}function preserving_reduced(e){return(n,r)=>{const o=e(n,r);return reduced_QMARK_(o)?reduced(o):o}}export function cat(e){return e=preserving_reduced(e),(...n)=>{switch(n.length){case 0:return e();case 1:return e(n[0]);case 2:return reduce(e,n[0],n[1])}}}export function rem(e,n){return e-n*quot(e,n)}export function memoize(e){const n=new Map;return(...r)=>{const o=[r.length,...r],u=get_in(n,o);if(void 0===u){const u=e(...r);return assoc_in_BANG_(n,o,u),u}return u}}export function peek(e){return array_QMARK_(e)?e[e.length-1]:first(e)}export function pop(e){if(array_QMARK_(e)){const n=[...e];return n.pop(),n}return rest(e)}export function update_keys(e,n){const r=empty(e),o=getAssocMut(e)||assoc_BANG_;return reduce_kv(((e,r,u)=>o(e,n(r),u)),r,e),r}export function update_vals(e,n){const r=empty(e),o=getAssocMut(e)||assoc_BANG_;return reduce_kv(((e,r,u)=>o(e,r,n(u))),r,e),r}export function random_uuid(){return crypto.randomUUID()}export class Delay{constructor(e){this.f=e}_deref(){return this.realized||(this.v=this.f(),this.realized=!0),this.v}}function clj__GT_js_(e,n){if(n.has(e))return e;if(n.add(e),map_QMARK_(e))return update_vals(e,(e=>clj__GT_js_(e,n)));const r=typeConst(e);return r&&r!=OBJECT_TYPE?mapv((e=>clj__GT_js_(e,n)),e):e}export function clj__GT_js(e){return clj__GT_js_(e,new Set)}export function run_BANG_(e,n){reduce(((n,r)=>e(r)),null,n)}export function not_EQ_(...e){return not(_EQ_(...e))}class Volatile{constructor(e){this.v=e}_deref(){return this.v}}export function volatile_BANG_(e){return new Volatile(e)}export function vreset_BANG_(e,n){e.v=n}function toEDN(e,n=new WeakSet){if(null===e)return"nil";if("number"==typeof e||"boolean"==typeof e)return String(e);if("string"==typeof e)return JSON.stringify(e);if("bigint"==typeof e)return`${e}N`;if("object"==typeof e){if(n.has(e))return"#object[circular]";n.add(e);let r;switch(typeConst(e)){case ARRAY_TYPE:return`[${e.map((e=>toEDN(e,n))).join(" ")}]`;case SET_TYPE:return`#{${Array.from(e).map((e=>toEDN(e,n))).join(" ")}}`;case MAP_TYPE:return`#js/Map {${Array.from(e.entries()).map((([e,r])=>`${toEDN(e,n)} ${toEDN(r,n)}`)).join(", ")}}`;case LAZY_ITERABLE_TYPE:case LIST_TYPE:return`(${mapv((e=>`${toEDN(e,n)}`),e).join(", ")})`;default:return r=Object.keys(e),`{${r.map((r=>`:${r} ${toEDN(e[r],n)}`)).join(", ")}}`}}return`#object[${e.constructor.name}]`}export function pr_str(...e){return e.map(((e,n)=>toEDN(e))).join(" ")}export function prn(...e){return console.log(pr_str(...e))}
//# sourceMappingURL=/sm/48b431020c613de9fa6daa886aaa6652e85a2d308f90a685c02851aa7c3fff5b.map